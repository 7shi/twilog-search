# Twilog MCPサーバー

## なぜこの実装が存在するか

### SQLiteベース実装の削除とラッパー化
**Problem**: 従来のMCPサーバーではSQLiteベースの独自実装（database.ts、filters.ts）が存在し、SearchEngineと同様のフィルタリング機能が重複実装されていた。この二重実装により、機能追加時の修正箇所が分散し、保守性が大幅に低下していた。また、SQLiteとCSVの二重データアクセス層により、アーキテクチャの一貫性が損なわれていた。

**Solution**: SQLiteベースの実装を完全削除し、twilog_server.pyへの単純なWebSocketラッパーとして再設計。database.tsとfilters.tsを削除し、全ての処理ロジックをtwilog_server.pyに一元化。MCPサーバーはJSON-RPC 2.0リクエストの転送と結果のフォーマット変換のみを担当し、検索・フィルタリング・統計処理は全てサーバー側で実行する分離アーキテクチャを採用した。

### 統一APIによる一貫性確保
**Problem**: MCPサーバー独自のメソッド名や処理方式により、CLI（search.py）とMCPで異なるAPIが提供され、開発者の学習コストが増加していた。また、機能の追加・変更時に複数箇所でのAPI修正が必要になり、一貫性の維持が困難だった。

**Solution**: twilog_server.pyで提供されるメソッド名（search_similar、get_user_stats、get_database_stats、search_posts_by_text、embed_text）と完全に一致するAPIを実装。MCPとCLIで同じメソッド名、同じパラメータ、同じ結果形式を提供することで、統一されたAPI体験を実現。開発者は単一のAPI仕様を学習するだけで、両方のインターフェースを活用可能になった。

### WebSocket通信の標準化
**Problem**: 独自のWebSocket通信実装により、JSON-RPC 2.0プロトコルとの互換性が不十分で、標準的なRPCライブラリとの連携が困難だった。また、エラーハンドリングやタイムアウト処理が分散し、通信の信頼性に課題があった。

**Solution**: 完全なJSON-RPC 2.0準拠の通信実装を採用。リクエスト形式`{"jsonrpc": "2.0", "method": "search_similar", "params": {...}, "id": 1}`、レスポンス形式`{"jsonrpc": "2.0", "result": {...}, "id": 1}`による標準プロトコル対応。Streaming Extensions形式の分割送信にも対応し、大容量結果の効率的な転送を実現。接続タイムアウト（5秒）、適切なエラーメッセージ、WebSocket接続の自動復旧機能により、堅牢な通信層を構築した。

### MCPプロトコル最適化
**Problem**: MCPツールの結果表示において、検索結果や統計情報を人間が読みやすい形式で提供する必要があったが、生のJSON形式では可読性が低く、MCPクライアントでの利用体験が劣化していた。

**Solution**: 各ツールの結果をMCPのcontentフォーマット（type: 'text'）に最適化して返却。検索結果は「順位: 類似度 - @ユーザー名」形式での整理、統計情報は表形式での見やすい表示、エラーメッセージの日本語対応により、MCPクライアントでの実用性を向上。結果の構造化により、Claude等のAIアシスタントが内容を理解しやすい形式を提供した。

### コマンドライン引数の簡素化
**Problem**: 従来の実装では`--db`引数によるSQLiteファイル指定が必要だったが、CSVベース統一により、データベースファイルが不要になった。しかし、WebSocketサーバーのURL指定は必要で、引数体系の見直しが必要だった。

**Solution**: `--db`引数を削除し、`--websocket`引数のみに簡素化。デフォルトURL（ws://localhost:8765）により引数省略を可能にし、基本的な利用では引数指定不要の簡単起動を実現。ヘルプ機能（`--help`、`-h`）により、利用方法の確認を容易にした。

### フィルタリング機能の委譲と個別パラメータ対応
**Problem**: MCPサーバー独自のフィルタリング実装（UserFilter、DateFilter、重複除去等）により、SearchEngineと同様の複雑なロジックが重複し、機能の同期が困難だった。また、フィルタリングパラメータの形式がSearchEngineと異なり、一貫性が欠如していた。さらに、CLIクライアントで利用可能な詳細なフィルタリング設定（SearchSettings）がMCPサーバーから利用できず、機能の不整合が発生していた。MCPクライアントからの利用を考慮すると、ネストした設定オブジェクトよりも個別パラメータの方が使いやすいという課題もあった。

**Solution**: 全てのフィルタリング機能をtwilog_server.pyのSearchEngineに委譲し、MCPサーバーではパラメータの転送のみを実行。MCPクライアントからは`user_filter`、`date_filter`、`top_k`を個別のオプショナルパラメータとして受け付け、サーバー送信時にSearchSettings形式に変換する方式を採用。重複除去機能は検索結果の質を向上させる基本機能であるため常時有効とし、パラメータから除外。`top_k`パラメータはサーバーリソース保護のため1-100の範囲制限を設定し、スキーマレベルでバリデーションを実装。これにより、MCPクライアントでの使いやすさを保ちながら、サーバー側の統一されたSearchSettings形式との互換性を確保した。integer型の適切な使用により、整数パラメータの型安全性も確保した。

### エラーハンドリングの統一
**Problem**: WebSocket通信、JSON解析、MCPレスポンス生成の各段階で個別のエラーハンドリングが必要だったが、従来の実装では不整合があり、デバッグが困難だった。また、MCPプロトコルでエラーが発生した場合の標準的な処理方法が不明確で、クライアント側でエラーと正常なレスポンスを区別することができなかった。

**Solution**: 階層的なエラーハンドリングシステムを実装。WebSocket接続エラー（ECONNREFUSED、ETIMEDOUT）の適切な分類、JSON-RPC 2.0エラーの標準的な処理、MCPレスポンスでのエラー情報の統一フォーマット化により、問題の特定と解決を効率化。MCPプロトコルに準拠した`isError: true`フラグをエラーレスポンスに追加することで、クライアント側でエラー状態を正確に判定可能にした。全てのエラーメッセージを日本語化し、ユーザーフレンドリーな体験を提供した。

### 構造化レスポンスデータへの対応
**Problem**: サーバー側のデータ構造変更により、検索結果が従来の平坦化された配列`[rank, score, postData]`から構造化されたオブジェクト`{rank, score, post}`形式に変更されたため、従来のデータ処理ロジックでは`toFixed()`エラーが発生し、結果の表示が正常に動作しなくなった。

**Solution**: レスポンス処理ロジックを構造化データ形式に対応するように修正。`result.rank`、`result.score`、`result.post`としてアクセスし、型安全性チェック（`typeof result.score === 'number'`）を追加してエラーを防止。これにより、サーバー側のStreaming Extensions仕様変更と連動し、一貫性のある構造化データ処理を実現した。

### 検索モード対応とパラメータ拡張
**Problem**: TwilogClientで提供されている詳細な検索機能（modeパラメータによる検索対象指定、weightsパラメータによる重み付け、search_posts_by_textのsource指定）がMCPサーバーでサポートされておらず、機能の不整合が発生していた。また、CLIで利用可能な多様な検索オプションをMCP経由では利用できないため、統一的なAPI体験が提供できていなかった。

**Solution**: search_similarツールにmodeパラメータ（content, reasoning, summary, average, maximum, minimum）とweightsパラメータ（重み付け配列）を追加し、search_posts_by_textツールにsourceパラメータ（content, reasoning, summary）を追加。これらのパラメータをWebSocketリクエストに適切に転送することで、TwilogClientと同等の検索機能をMCP経由でも利用可能にした。

### YAML形式による統一的なレスポンス表示
**Problem**: 各ツールのレスポンス表示において、カスタムフォーマット処理が個別に実装されており、データ構造の変更時に複数箇所の修正が必要になっていた。特に、reasoning、summary、tagsといった新しい項目が追加された際に、表示ロジックの更新を忘れるリスクがあった。また、手動でのフォーマット処理により、表示の一貫性が保たれていなかった。

**Solution**: js-yamlライブラリを導入し、全ての構造化レスポンス（search_similar、get_user_stats、get_database_stats、search_posts_by_text、get_status）をYAML形式で統一して表示。これにより、新しい項目が追加されても自動的に表示され、フォーマット処理のメンテナンス負荷を大幅に削減。階層構造の可読性向上により、MCPクライアントでのデータ理解も容易になった。

### 整形テキスト表示形式への変更
**Problem**: YAML形式の出力はMCPクライアント（Claude Code等）では文字列として扱われるため、構造化データとして活用できない問題があった。また、長いYAMLテキストはスクロールが必要で視認性に課題があった。さらに、reasoning/summary/tagsはLLMによって生成されたものであり、MCPクライアント（LLM）に再度見せる必要がないという冗長性の問題もあった。

**Solution**: 全てのツールの出力を整形テキスト形式に変更。search_similarでは🔍アイコンを使用したランキング形式で、投稿内容の改行保持・空行詰め処理を実装し、reasoning/summary/tagsを削除。get_statusでは🟢/🔴アイコンによる状態表示と📊データ統計セクションを追加。数値にはカンマ区切りを適用し、URLは日時の後に配置。js-yamlライブラリは削除し、単一の整形テキストブロックによる見やすい表示を実現。これにより、MCPクライアントでの可読性と処理のしやすさが大幅に向上した。