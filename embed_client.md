# embed_client

## なぜこの実装が存在するか

### クラスベースクライアントアーキテクチャの必要性
**Problem**: embed_server.pyがBaseEmbedServerを基底とした継承前提の設計に移行したため、クライアント側も同様の拡張可能なアーキテクチャが必要になった。従来の関数ベースクライアントでは、サーバーの新機能に対応したクライアント拡張が困難だった。

**Solution**: BaseEmbedClientを基底クラスとした継承前提のアーキテクチャを採用。サーバーの追加機能に対応するクライアント拡張を、サブクラスでのメソッドオーバーライドにより実現可能にした。

### 全リクエストタイプのメソッド化による体系化
**Problem**: embed_server.pyがサポートする各リクエストタイプ（status、check_init、stop、embed）を個別に実装する必要があり、統一的なアクセス方法が求められていた。

**Solution**: サーバーの全リクエストタイプに対応するメソッドを実装し、統一的なインターフェースを提供。`get_status()`、`check_init()`、`stop_server()`、`embed_text()`として体系化。

### 共通処理の基底クラス集約による保守性向上
**Problem**: WebSocket通信の接続、送信、受信処理が各リクエストで重複実装されると、エラーハンドリングの統一性や保守性が低下する可能性があった。

**Solution**: `_send_request()`メソッドで共通処理を集約し、各リクエストメソッドは業務ロジックのみに集中。タイムアウト、接続エラー、通信エラーの処理を統一化。

### 継承による機能拡張の標準化
**Problem**: BaseEmbedServerでサブクラスが`handle_additional_request()`で独自機能を追加できる設計のため、クライアント側も対応する拡張機能が必要だった。

**Solution**: `handle_additional_request()`メソッドを基底クラスに実装し、サブクラスでオーバーライドすることで独自リクエストタイプに対応。サーバーとクライアントの拡張パターンを統一。

### レスポンス処理のユーティリティ化
**Problem**: ベクトル化レスポンスの成功判定、データ抽出、Base64デコードなどの処理が各所で重複実装されると、処理の一貫性が保てない。

**Solution**: `is_success()`、`extract_vector_data()`、`decode_vector_size()`をユーティリティメソッドとして実装。レスポンス処理の標準化と再利用性を向上。

### WebSocket RPCの二重ラップアーキテクチャ
**Problem**: WebSocketベースのRPCサーバーに対して、プログラムからのAPI呼び出しとコマンドラインからのCLI操作の両方を提供する必要があった。従来の単一インターフェースでは、利用者のニーズに応じた柔軟な操作方法を提供できなかった。

**Solution**: API Layer（BaseEmbedClient/EmbedClient）とCommand Layer（EmbedCommand）の二重ラップアーキテクチャを採用。WebSocket RPCをPythonのasyncメソッドとしてラップし、さらにそれをCLIコマンドとしてラップすることで、同一サーバーに対する複数のアクセス方法を実現。

### 名前ディスパッチアーキテクチャによるコマンド処理の簡潔化
**Problem**: argparseのサブコマンドを処理する際の長いif-elif文は、新しいコマンドの追加時にコードの保守性を低下させ、実装の重複を招く可能性があった。

**Solution**: EmbedCommandクラスで`getattr(self, args.command)`による動的メソッド呼び出しを採用。サブコマンド名と同名のメソッドを自動的に呼び出すことで、新しいコマンドの追加時はparserとメソッドの追加のみで対応可能にした。この名前ディスパッチパターンはサーバー側のJSON-RPCメソッド処理と統一され、クライアント・サーバー間で一貫したアーキテクチャを実現。

### 継承によるコマンド機能の段階的拡張
**Problem**: 基本的な埋め込み機能に加えて、Twilog固有の検索機能など、用途に応じた拡張コマンドを効率的に実装する必要があった。

**Solution**: EmbedCommandを基底クラスとした継承アーキテクチャにより、基本コマンド（status、check_init、embed、stop）を継承し、用途固有のコマンド（query等）を段階的に追加。コードの重複を避けながら機能拡張を実現。

### JSON-RPC 2.0クライアント統一
**Problem**: 独自JSON形式による通信により、標準的なRPCクライアントライブラリとの互換性がなく、エラーハンドリングも一貫性がなかった。

**Solution**: JSON-RPC 2.0標準に完全準拠したクライアント実装。リクエストは`{"jsonrpc": "2.0", "id": 1, "method": "embed_text", "params": {"text": "..."}}`形式、レスポンスは`{"jsonrpc": "2.0", "id": 1, "result": {...}}`形式で統一し、標準エラーコードによる一貫性のあるエラーハンドリングを実現。

### メソッド名の2語化による一貫性向上
**Problem**: サーバー側の`status`、`stop`、`embed`などの単語メソッド名に対応するクライアント側メソッドの命名が不統一で、APIの理解が困難だった。

**Solution**: 全メソッド名を2語形式に統一（`get_status`、`stop_server`、`embed_text`、`check_init`）し、サーバー側のJSON-RPCメソッド名と完全に一致させた。これにより、クライアント・サーバー間でのメソッド対応関係が明確になり、APIの一貫性を向上。

### 旧形式サポートの完全削除
**Problem**: 後方互換性のために旧形式と新形式の両方をサポートすると、コードが複雑化し、保守性が低下する。

**Solution**: 旧形式のサポートを完全に削除し、JSON-RPC 2.0のみに統一。これにより、コードの簡潔性と保守性を向上させ、標準プロトコルへの完全移行を実現。

### リクエストID連番管理による一意性保証
**Problem**: JSON-RPCリクエストで固定ID（1）を使用すると、複数の並行リクエストや長時間のセッションでレスポンスの対応関係が不明確になり、デバッグや問題追跡が困難になる可能性があった。

**Solution**: グローバル変数`_request_id_counter`による連番管理を実装し、`_get_next_request_id()`関数で各リクエストに一意のIDを割り当て。これによりJSON-RPC標準に準拠した適切なリクエスト・レスポンス対応関係を確立し、通信の透明性とデバッグ容易性を向上。
