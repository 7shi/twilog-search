# MCPプロトコルの技術的位置づけ

## MCPの本質

MCPは本質的にIDL（Interface Definition Language）をJSONで表現したRPC（Remote Procedure Call）システムである。

### 既存技術との比較

#### CORBAやSOAPとの類似点
- インターフェース定義による型安全性
- クライアント・サーバー間の標準化された通信
- プロトコルレベルでの相互運用性

#### 主な違い
- **軽量性**: XMLではなくJSONを使用
- **AI特化**: LLMとの統合を前提とした設計
- **シンプルさ**: CORBAの複雑なオブジェクトモデルを避け、関数呼び出しに特化

## 設計思想の変遷

### XML→JSON移行の背景
Web APIがXMLからJSONに移行した理由と同様：

1. **パフォーマンス**: JSONの方が軽量でパース速度が速い
2. **可読性**: 人間にとって読みやすく、デバッグが容易
3. **JavaScript親和性**: ブラウザ環境でのネイティブサポート
4. **冗長性の削減**: XMLタグの開始・終了による冗長性を排除

### 関数特化の理由
オブジェクト指向的な型表現ではなく、関数呼び出しに特化した理由：

- LLMは「関数呼び出し」の概念を理解しやすい
- オブジェクト指向の複雑な継承・多態性よりも、単純な入出力の方がAIにとって扱いやすい
- 関数単位での呼び出しは、LLMの「tool calling」パラダイムと自然に対応

## 汎用性

MCPは「LLM専用のプロトコル」ではなく、通常のプログラムからも利用可能：

### 一般的なプログラムからの利用
- MCPクライアントライブラリを使ってMCPサーバーに接続
- 関数呼び出しでツールを実行
- 通常のAPI呼び出しと同じ感覚で使用可能

### 実際の利用シーン
- 自動化スクリプト
- データ処理パイプライン
- バッチ処理
- 他のアプリケーションとの統合

## プロトコル構造の詳細

### レイヤー構造
MCPは以下の2層構造で構成される：

1. **JSON-RPC 2.0層**: 通信プロトコル
   - `id`, `jsonrpc`, `result`, `error`などの基本フィールド
   - 任意の値を`result`に格納可能

2. **MCP層**: アプリケーションプロトコル
   - `content`配列による統一的なコンテンツ表現
   - `type`フィールドによるコンテンツタイプ指定
   - マルチメディアサポート

### コンテンツタイプ仕様

MCPは多様なコンテンツタイプをサポートしており、テキスト専用ではない：

#### 基本コンテンツタイプ
- **`"text"`**: 通常のテキストコンテンツ
- **`"image"`**: Base64エンコードされた画像データ（`data`, `mimeType`）
- **`"audio"`**: Base64エンコードされた音声データ（`data`, `mimeType`）

#### リソースコンテンツタイプ
- **`"resource"`**: ファイルやWebリソースの内容
- **`"resource_link"`**: リソースへのリンク情報

### 標準化の意義

`content`配列と`type`フィールドは、MCPクライアント（LLMなど）が応答を正しく解釈するために必要な標準フォーマット。これにより：

- **拡張性**: 将来的な新しいコンテンツタイプに対応
- **互換性**: 異なるMCPサーバー間での一貫性
- **型安全性**: TypeScriptでの型チェック支援

## 結論

MCPは「AIエージェント向けの軽量なCORBA」あるいは「AI時代のWeb API」と位置づけられる。LLMの普及をきっかけに設計されたが、結果的に軽量で使いやすい汎用的なRPCフレームワークとなっている。

JSON-RPC 2.0をベースとしながら、独自のコンテンツ表現仕様により、テキストだけでなくマルチメディアコンテンツも扱える包括的なプロトコルとして設計されている。