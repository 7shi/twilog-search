# Twilogベクトル検索システム設計計画

## なぜこの実装が存在するか

### 意味的検索の必要性
**Problem**: 単純な単語マッチングでは「git」「コミット」「リポジトリ」などの関連語や、表現の多様性に対応できない。「ソースコード管理」「変更履歴」「バージョン管理システム」などの同義語も検索対象にならない。

**Solution**: テキストをベクトル化し、コサイン類似度による意味的検索を実装。表現が異なっても概念的に近い投稿を発見できる。

### データ規模と実装方式の選択
**Problem**: 22万件の投稿データに対して、複雑なベクトルDBやクラウドサービスを導入すると過剰な複雑性とコストが発生する。

**Solution**: 分割ファイル格納方式を採用。
- 1000件ごとの分割処理で安全性確保
- safetensors形式による高速読み込み
- 中断・再開機能による長時間処理への対応
- インメモリ検索により数ミリ秒での全件検索

### SQLiteベクトル拡張の回避
**Problem**: sqlite-vssやsqlite-vecなどの拡張は導入が複雑で、依存関係が増える。また、SQLiteのBLOBでは直接的なコサイン類似度検索が困難。

**Solution**: safetensors形式での別ファイル保存を採用。
- 高速なメモリマップによる瞬時ロード
- 型安全性とバイナリ効率性
- 依存関係の最小化（safetensors + numpy）

### データ前処理の重要性
**Problem**: 投稿データにはURL、メンション、ハッシュタグなどのノイズが含まれ、意味的ベクトル化の精度を低下させる。

**Solution**: ベクトル化前にURL除去、空白正規化などの前処理を実装。意味のあるテキストのみを対象とする。

### タグ検出システムの設計
**Problem**: 22万件の投稿から手動でタグを抽出するのは現実的でない。また、クラウドAPIでは大量データの処理コストが高い。

**Solution**: ローカルLLM（Ollama + Qwen3:4b）による自動タグ付けシステム。
- GPU環境での効率的なシーケンシャル処理
- チェックポイント機能による中断・再開対応
- Pydanticスキーマによる構造化出力
- 分割JSONL保存による効率的な管理
- 1件ずつ追記保存による処理安全性

### WebSocketベースのアーキテクチャ分離と統合
**Problem**: ベクトル検索機能をアプリケーションに統合すると、重いライブラリ（torch、SentenceTransformers）の読み込みにより、開発時の頻繁な再起動で生産性が低下する。また、MCPサーバー（TypeScript）とSearchEngine（Python）でフィルタリング機能が二重実装され、保守性とコードの一貫性に問題があった。

**Solution**: SearchEngine中心の統合アーキテクチャを採用。
- **twilog_server.py**: 統合検索サーバー（デーモン）
  - Ruri v3モデル初期化とembeddingsデータ読み込み
  - SearchEngineインスタンスによるフィルタリング統合
  - MCP互換メソッド（search_similar, get_user_stats等）提供
  - meta.jsonからCSVパス自動取得
- **search.py**: 軽量フロントエンド
  - twilog_server.pyのsearch_similarメソッド使用
  - UI処理と結果表示のみに特化
  - SearchEngineのインポートを削除、数秒での高速起動
- **MCPサーバー**: 単純なWebSocketラッパー
  - twilog_server.pyの各メソッドを直接転送
  - SQLiteベース実装（database.ts, filters.ts）を完全削除
  - フィルタリング処理の重複削除、コード簡素化
- 機能の一元化による保守性向上と開発効率改善

### ハイブリッド検索システムの必要性
**Problem**: 単純なベクトル検索では、直接的な類似度のみで判断するため、関連性の高い投稿を見逃す可能性がある。例えば「バージョン管理」で検索した際に、内容は異なるが「git」タグを持つ関連投稿が検索対象外になる。

**Solution**: ベクトル検索とタグ検索を組み合わせたハイブリッド検索を実装。
- 検索語と投稿内容の直接的なベクトル類似度検索
- 検索語と類似するタグを特定し、そのタグを持つ投稿も対象化
- 二つの検索結果を統合してランキング
- 網羅性と精度の両立を実現

### 検索結果統合の重要性
**Problem**: 直接類似度検索とタグ経由検索で異なるスコア体系を持つため、単純な結果マージでは適切なランキングができない。

**Solution**: スコア統合戦略を採用。
- 直接類似度: 重み0.7（内容の関連性を重視）
- タグ経由類似度: 重み0.3（関連トピックの発見性を重視）
- 重複投稿の除去と最終ランキング算出
- 検索意図に応じた重み調整が可能

## 技術選択の根拠

### 日本語embedding model
**採用技術**: Ruri v3（cl-nagoya/ruri-v3-310m）
- 日本語特化の310Mパラメータモデル
- 「検索文書: 」プレフィックスによる最適化
- 1024次元のベクトル表現
- GPU環境での高速処理

### ファイル構成
```
twilog/
├── twilog.csv                # 元データ（CSVベースアクセス）
├── embeddings/               # ベクトル検索用（分割ファイル）
│   ├── 0000.safetensors     # 投稿ベクトル（1000件ずつ）
│   ├── 0001.safetensors     # ...
│   ├── meta.json            # メタデータ（CSVパス含む）
│   └── ...
├── tags/                     # タグ情報（分割ファイル、オプション）
│   ├── 0000.jsonl           # タグデータ（1000件ずつ）
│   └── ...
├── embed_server.py           # 基底クラス（BaseEmbedServer）
├── twilog_server.py          # 統合WebSocketサーバー（SearchEngine統合）
├── twilog_client.py          # テスト用クライアント
├── search.py                 # 軽量検索クライアント（フロントエンド化）
├── search_engine.py          # フィルタリング機能の中核
├── data_csv.py               # CSVベースデータアクセス層
├── extract_tags.py           # CSVベースタグ付けスクリプト（完了）
└── mcp/src/index.ts          # MCPラッパー（SQLite実装削除済み）
```

## 実装状況

### 完了済み: 統合アーキテクチャシステム
- **embed_server.py**: 基底クラス（BaseEmbedServer）
  - 共通のデーモン管理とWebSocket通信
  - 拡張可能なリクエスト処理システム
  - エラーハンドリングと進捗報告
  - サーバー種別の動的識別機能
- **twilog_server.py**: 統合WebSocketサーバー（デーモン）
  - Ruri v3モデルによるベクトル検索
  - SearchEngineインスタンス統合によるフィルタリング
  - MCP互換メソッド（search_similar, get_user_stats等）
  - meta.jsonからCSVパス自動取得
  - 分割送信による大量結果の効率的転送
- **search_engine.py**: フィルタリング機能の中核
  - ユーザーフィルタリング、日付フィルタリング
  - 重複除去とランキング処理
  - CSV直接アクセスによるデータ取得
- **search.py**: 軽量検索クライアント（フロントエンド化）
  - twilog_server.pyのsearch_similarメソッド使用
  - UI処理と結果表示のみに特化
  - 数秒での高速起動（軽量化）
- **mcp/src/index.ts**: MCPラッパー
  - twilog_server.pyの各メソッドを直接転送
  - SQLiteベース実装削除によるシンプル化
  - database.ts/filters.ts削除済み
- **extract_tags.py**: CSVベースタグ付けスクリプト
  - data_csv.pyによるCSVファイル直接読み込み
  - strip_content関数による前処理統合
  - SQLiteデータベース構築不要
- **性能**: 22万件に対して数ミリ秒での高速検索
- **保守性**: SearchEngine中心の一元化による重複削除
- **開発効率**: CSVベースによる単純化とセットアップ時間短縮

### 将来実装予定: ハイブリッド検索システム

#### 基本検索フロー（タグ付け完了後）
1. **検索語のベクトル化**: twilog_server.pyでRuri v3によるベクトル化
2. **並列検索実行**:
   - A. twilog_server.py内でembeddings/とのコサイン類似度検索
   - B. search.py内でtags/内のJSONLファイルからのタグ検索
3. **タグ経由投稿の取得**: 類似タグに紐づく投稿をJSONLから取得
4. **スコア統合**: 直接類似度とタグ経由類似度を重み付け統合
5. **結果ランキング**: 重複除去と最終スコア順でソート

#### タグ検索の実装案（要検証）

**案1: ベクトルベース類似タグ検索**
- **アプローチ**: クエリ→タグベクトル類似度→該当投稿選択
- **実装手順**:
  1. 抽出済みタグ一覧をRuri v3でベクトル化（事前処理）
  2. 検索クエリとタグベクトル間のコサイン類似度計算
  3. 閾値以上の類似度を持つタグを特定
  4. 該当タグを含む投稿を検索結果に追加
- **利点**: 既存のRuri v3モデル活用、実装シンプル
- **課題**: タグベクトル化の事前処理が必要

**案2: LLMベースタグ生成検索**
- **アプローチ**: クエリ→LLMタグ生成→タグマッチング→投稿選択
- **実装手順**:
  1. 検索クエリをOllama + Qwen3に投げてタグ生成
  2. 生成タグと既存タグの完全一致・部分一致
  3. マッチしたタグを持つ投稿を特定
  4. 該当投稿を検索結果に統合
- **利点**: 柔軟で意味的な関連性発見が可能
- **課題**: LLM呼び出しレイテンシ、生成タグ品質の不確実性

この設計により、高精度な意味的検索と網羅的な関連投稿発見を22万件規模で実現予定。SearchEngine中心の統合アーキテクチャにより、タグ検索機能の追加時もSearchEngineでの実装のみでCLI・MCP両方に反映可能。
