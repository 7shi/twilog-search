# Twilogベクトル検索システム設計計画

## なぜこの実装が存在するか

### 意味的検索の必要性
**Problem**: 単純な単語マッチングでは「git」「コミット」「リポジトリ」などの関連語や、表現の多様性に対応できない。「ソースコード管理」「変更履歴」「バージョン管理システム」などの同義語も検索対象にならない。

**Solution**: テキストをベクトル化し、コサイン類似度による意味的検索を実装。表現が異なっても概念的に近い投稿を発見できる。

### データ規模と実装方式の選択
**Problem**: 22万件の投稿データに対して、複雑なベクトルDBやクラウドサービスを導入すると過剰な複雑性とコストが発生する。

**Solution**: 分割ファイル格納方式を採用。
- 1000件ごとの分割処理で安全性確保
- safetensors形式による高速読み込み
- 中断・再開機能による長時間処理への対応
- インメモリ検索により数ミリ秒での全件検索

### データ前処理の重要性
**Problem**: 投稿データにはURL、メンション、ハッシュタグなどのノイズが含まれ、意味的ベクトル化の精度を低下させる。

**Solution**: ベクトル化前にURL除去、空白正規化などの前処理を実装。意味のあるテキストのみを対象とする。

### タグ検出システムの設計
**Problem**: 22万件の投稿から手動でタグを抽出するのは現実的でなく、クラウドAPIの利用はコストと処理時間の課題を伴う。
**Solution**: ローカルLLMによる逐次処理と、Gemini APIによるバッチ処理を組み合わせたハイブリッドな自動タグ付けシステムを構築。これにより、コストと処理時間のバランスを取りながら、大規模データに対応する。

### ハイブリッド検索システムの必要性
**Problem**: 単純なベクトル検索では、直接的な類似度のみで判断するため、関連性の高い投稿を見逃す可能性がある。例えば「バージョン管理」で検索した際に、内容は異なるが「git」タグを持つ関連投稿が検索対象外になる。

**Solution**: ベクトル検索とタグ検索を組み合わせたハイブリッド検索を実装。
- 検索語と投稿内容の直接的なベクトル類似度検索
- 検索語と類似するタグを特定し、そのタグを持つ投稿も対象化
- 二つの検索結果を統合してランキング
- 網羅性と精度の両立を実現

### 検索結果統合の重要性
**Problem**: 直接類似度検索とタグ経由検索で異なるスコア体系を持つため、単純な結果マージでは適切なランキングができない。

**Solution**: スコア統合戦略を採用。
- 直接類似度: 重み0.7（内容の関連性を重視）
- タグ経由類似度: 重み0.3（関連トピックの発見性を重視）
- 重複投稿の除去と最終ランキング算出
- 検索意図に応じた重み調整が可能

### WebSocketベースのアーキテクチャ分離と統合
**Problem**: ベクトル検索機能をアプリケーションに統合すると、重いライブラリ（torch、SentenceTransformers）の読み込みにより、開発時の頻繁な再起動で生産性が低下する。また、MCPサーバー（TypeScript）とSearchEngine（Python）でフィルタリング機能が二重実装され、保守性とコードの一貫性に問題があった。

**Solution**: SearchEngine中心の統合アーキテクチャを採用。
- **twilog_server.py**: 統合検索サーバー（デーモン）
- **search.py**: 軽量フロントエンド
- **MCPサーバー**: 単純なWebSocketラッパー
- 機能の一元化による保守性向上と開発効率改善

## 自動タグ付けパイプライン

### 1. 比較検討: 逐次処理 vs バッチ処理
- **逐次処理 (`add_tags.py`)**: ローカルLLM（Ollama）を利用。小規模なテストやGPU環境下での実行には向くが、全データ（22万件）の処理に約158時間かかると試算され、スケーラビリティに課題。
- **バッチ処理（Gemini API）**: クラウドの並列処理能力を最大限に活用。全データ処理を約9時間で完了（17.6倍高速化）し、コストと時間の両面で圧倒的に優位であることが確認された。

### 2. バッチ処理パイプライン
Geminiバッチ処理を効率化するため、以下のツール群を開発・整備した。
- **リクエスト生成 (`batch_generate.py`)**: APIの仕様に合わせ、1万件ずつのJSONLリクエストファイルを生成する。
- **ジョブ管理 (`gemini-batch`)**: バッチジョブの投入、進捗監視、結果取得を自動化する独立CLIツール。
- **結果分析 (`batch_usage.py`)**: 処理結果のトークン使用量やコストを計算・検証し、データ品質を担保する。
- **結果統合 (`batch_merge.py`)**: 全バッチの結果ファイルをマージし、重複除去と整合性チェックを経て、単一のタグ付きデータセットを生成する。

### 3. ハイブリッド検索用データ生成
- **要旨ベクトル化 (`batch_vectorize.py`)**: 統合されたタグ情報（reasoning, summary）を個別にベクトル化し、内容の類似度だけでなく、LLMが生成した要約や理由に基づいた多角的な検索を可能にする。

### ローカルLLM可用性検証（予定）
Geminiバッチ処理は効率的だが、単一APIへの依存により選択肢が制限される。ローカルLLM（Ollama + Qwen3）の可用性を検証し、API依存のリスクを軽減する必要がある。
- **検証対象**: ローカルLLMによるタグ付け処理の実用性評価
- **評価指標**: 実用最低ラインの品質達成、処理安定性、依存関係の独立性
- **実装タイミング**: 統合システム完了後のオプション作業
- **比較項目**: 
  - 処理時間（Gemini: 9時間 vs ローカル: 158時間）
  - 品質（実用最低ライン達成の有無）
  - 可用性（API依存なし、完全ローカル処理）
  - コスト（API料金 vs 電力・時間コスト）
- **期待結果**: API依存リスクを軽減するローカル処理選択肢の確立
- **現状**: Geminiバッチ処理が効率性で圧倒的優位、可用性検証が残り課題

## ファイル構成
```
twilog/
├── twilog.csv                # 元データ（CSVベースアクセス）
├── embeddings/               # ベクトル検索用（分割ファイル）
│   ├── 0000.safetensors      # 投稿ベクトル（1000件ずつ）
│   ├── ...                   # ...
│   └── meta.json             # メタデータ（CSVパス含む）
├── tags/                     # タグ情報（分割ファイル、オプション）
│   ├── 0000.jsonl            # タグデータ（1000件ずつ）
│   └── ...
├── batch/                    # バッチAPIリクエスト（オプション）
│   ├── 001.jsonl             # Geminiバッチ用リクエスト（1万件ずつ）
│   ├── ...                   # ...
│   ├── results/              # Geminiバッチ処理結果（分割ファイル）
│   │   ├── 001.jsonl         # バッチ処理結果（1万件ずつ、reasoning/summary含む）
│   │   └── ...               # ...
│   ├── results.jsonl         # 統合されたバッチ処理結果（全件、batch_merge.py出力）
│   ├── tags.tsv              # タグデータ（TSV形式、tag_dump.py出力）
│   ├── tags.txt              # ユニークタグリスト（TXT形式、tag_vectorize.py出力）
│   └── tags.safetensors      # タグベクトル（safetensors形式、tag_vectorize.py出力）
├── src/                      # Pythonソースコード
│   ├── tag_dump.py           # タグデータ抽出
│   ├── tag_vectorize.py      # タグベクトル化  
│   ├── tag_reader.py         # 統合データアクセス
│   ├── batch_*.py            # バッチ処理ツール群（4段階パイプライン）
│   ├── search*.py            # 検索システム（統合サーバー＋軽量フロントエンド）
│   ├── embed_*.py            # ベクトル化基盤（サーバー＋クライアント）
│   └── *.py                  # その他ツール・ユーティリティ
├── research/                 # 実験・調査コード（研究目的）
│   ├── README.md             # 実験ツール目録と研究成果まとめ
│   ├── *_validation_*.py     # 検索アルゴリズム検証実験
│   ├── tag_*.py              # タグ分析・調査ツール
│   └── *.md                  # 各実験の詳細レポート
└── mcp/src/index.ts          # MCPラッパー
```

## 実装状況

### 完了済み: コア機能とアーキテクチャ
- **データ処理パイプライン**:
  - **タグ付け**: Geminiバッチ処理による22万件のタグ付け（`batch_generate.py` -> `gemini-batch` -> `batch_merge.py`）
  - **ベクトル化**: `batch_vectorize.py`によるハイブリッド検索用データの生成
- **統合アーキテクチャ**:
  - `twilog_server.py`を中心としたデーモン構成
  - `search_engine.py`へのフィルタリング機能集約
  - `search.py`の軽量フロントエンド化
  - `mcp/src/index.ts`のWebSocketラッパー化によるSQLite実装の完全排除
- **ハイブリッド検索システム**:
  - 6種類の検索モード（content, reasoning, summary, average, maximum, minimum）
  - `SearchEngine`レベルでの重み付けスコア統合
  - 詳細は[ハイブリッド検索実装レポート](docs/20250715-hybrid-search.md)を参照
- **性能と保守性**:
  - 22万件データに対して数ミリ秒での高速検索
  - SearchEngineへの機能一元化によるコード重複の排除

### 完了済み: UI/UXと操作性向上
- **クライアント機能**:
  - **コマンドシステム**: `@command`デコレーターによる宣言的なコマンド登録と管理
  - **メニューUI**: `settings_ui.py`による統一的なメニューと数値ショートカット
  - **検索結果表示**: ページネーション機能、URL右寄せ、タグの色分け表示
  - **表示モード**: `/view`コマンドによる詳細表示機能
  - 詳細は[メニューUI設計レポート](docs/20250716-menu.md)を参照
- **ユーザー入力支援**:
  - **Tab補完**: `safe_input.py`によるユーザー名のTab補完
  - **類似ユーザー推薦**: Levenshtein距離を用いたタイポ訂正支援
- **情報管理**:
  - **UserInfoクラス**: `user_info.py`によるユーザー統計情報の一元管理
  - **MCP連携**: 検索モード対応とYAML形式での統一出力

### 完了済み: タグ分析基盤ツール群

#### タグ集計・分析システム（完了）
**Problem**: 22万件のタグ付けデータが完了したが、タグ自体の集計・分析機能がないため、タグの使用頻度や関連性を把握できない。

**Solution**: タグ分析基盤の3段階パイプラインを実装。
- ✅ **タグデータ抽出**: `tag_dump.py`によるバッチ処理結果からTSV形式でのタグデータ抽出
- ✅ **タグベクトル化**: `tag_vectorize.py`による全タグの事前ベクトル化、safetensors形式保存、形状最適化（[N, 768]）
- ✅ **統合データアクセス**: `tag_reader.py`による分散データ（TSV、TXT、safetensors）の統合読み込み、遅延import対応

### 完了済み: 検索アルゴリズム実証研究

#### **研究成果サマリー**
**Problem**: タグベース検索システムの設計において、理論的設計と実用性能の関係を実証的に検証する必要があった。

**Solution**: `research/`ディレクトリで系統的な検証実験を実施。重要な設計判断を実証データに基づいて決定。

#### **主要な検証実験と成果**
- ✅ **ベクトル検索基盤検証**: `summary_vector_validation.py`による要約ベクトルの原文反映性確認（reasoning検索の優位性実証）
- ✅ **タグスコアリング手法比較**: `tag_reverse_search_*.py`シリーズによる6手法の性能検証、mean手法（平均順位736.2）の最優秀性を確認
- ✅ **最適化技術検証**: 全タグ類似度計算による43%の処理時間短縮を実証
- ✅ **コアタグ特定適中率検証**: `core_tag_validation_*.py`シリーズによる0.89閾値（平均5.1件/サンプル）での最適バランス発見
- ✅ **検索アルゴリズム限界検証**: コアタグ手法（平均順位31,896.3） vs 直接手法（平均順位736.2）で43倍の性能差を実証
- ✅ **タグ特性分析**: `research/tag_*.py`ツール群による包含関係、共起率、類似度の定量的分析

#### **研究による重要な発見**
1. **全タグ類似度計算の必須性**: top_k制限は「早期最適化の罠」であり、97%の情報損失で検索精度を3-6倍悪化させる
2. **mean手法の実用的優位性**: 複雑な統合手法よりシンプルな平均化が最優秀性能を発揮
3. **コアタグ手法の根本的限界**: LLM（Gemini）とベクトルモデル（Ruri v3）の表現空間不一致により実用困難
4. **タグの本質的特性**: 情報圧縮により検索には不適、分類・整理には最適という役割分担の確立

#### **設計への反映結果**
この実証研究により、「タグベース検索→タグベース情報整理」への方針転換が科学的根拠に基づいて決定された。実験により理論的魅力と実用性の乖離が明確になり、現行システムの最適性が確認された。

### 今後の予定: タグベース情報整理システム

#### **タグベース検索からタグベース分類への方針転換**
**Problem**: タグベース検索システムの実証検証により、タグが検索には不適であることが判明した。一方で、タグの本質的特性（情報圧縮・分類指向）は情報整理には最適である。

**Solution**: タグの特性を活かした情報整理・分類システムへの方針転換。検索ではなく、大量データの体系的整理と発見支援を目標とする。

#### 1. タグベース情報分類システム

**目的**: 22万件の投稿を体系的に整理し、知識の全体像を把握可能にする。

- **階層分析**: タグ包含関係（「代数学」→「数学」97.8%）による知識階層の構築
- **カテゴリ分類**: 主要領域（技術、学習、日常、etc.）の自動分類と統計
- **関連性マップ**: タグ共起ネットワークによる知識領域間の関連性可視化
- **時系列分析**: 関心の変遷パターンと知識蓄積の軌跡追跡

#### 2. 情報発見支援ツール

**目的**: 蓄積された知識の「再発見」と「棚卸し」を支援する。

- **未開拓領域発見**: 投稿数の少ないタグや関連性の薄い領域の特定
- **知識の偏り分析**: 特定分野への集中度や多様性の定量評価
- **関心の進化追跡**: タグ分布の時系列変化による学習・関心の軌跡可視化
- **関連投稿推薦**: 類似タグを持つ過去投稿の再発見支援

#### 3. 実装計画

1. **タグ階層分析ツール**: 包含関係と上位概念の体系化
2. **カテゴリ分類システム**: 主要領域の自動分類と統計表示
3. **時系列分析ツール**: 関心変遷の可視化とパターン分析
4. **知識マップ生成**: 共起ネットワークによる関連性の可視化
5. **情報整理ダッシュボード**: 各種分析結果の統合表示

#### 期待される価値

- **全体俯瞰**: 22万件の投稿から知識の全体像を把握
- **再発見支援**: 忘れていた過去の知見や関心領域の再発見
- **学習軌跡の可視化**: 自身の成長や関心の変化を客観視
- **知識の体系化**: 散在する情報を意味のある構造に整理

### **設計方針の重要な変更**

#### **コアタグベース検索の設計廃止**
**Problem**: 当初設計した「コアタグ特定→スコアリング」アプローチは理論的に優れているように見えたが、実証検証により実用性の低さが判明した。

**Solution**: 
- **採用継続**: 直接的なsummary→全タグ類似度計算によるmean手法
- **設計廃止**: 複雑なコアタグ経由のスコアリング手法
- **根拠**: LLM（Gemini）によるタグ抽出基準とベクトルモデル（Ruri v3）の表現空間が異なる方向性を持つため、中間変換段階が情報損失を招く

#### **シンプリシティの価値**
**教訓**: 複雑なアルゴリズムが必ずしも優れた結果をもたらすとは限らない。実用的検索システムでは：
1. **一貫性** > 特殊ケースでの部分最適化
2. **保守性** > 複雑な多段階処理
3. **実証性** > 理論的魅力

#### **タグの本質的特性と適切な活用範囲**
**Problem**: コアタグベース検索の失敗により、タグそのものが持つ本質的な限界と、検索システムでの適切な活用方法を明確化する必要があった。

**Solution**: タグの特性分析により、検索における適切な役割分担を確立。

**タグの本質的特性**:
1. **情報圧縮性**: 豊富な文脈→少数キーワードへの圧縮（情報損失80-85%）
2. **分類指向設計**: LLMによる既知カテゴリへの割り当てに最適化
3. **粒度の粗さ**: 検索で重要な微細な関連性・ニュアンスの欠失

**情報理論的観点**:
- **タグ**: クエリより情報量が絞られた抽象化されたラベル
- **分類最適化**: 既知カテゴリへの効率的な割り当てに特化
- **検索限界**: 情報の圧縮により、検索で必要な詳細文脈が失われる

**適切な活用範囲**:
- ✅ **分類・カテゴライゼーション**: 優秀（本来の設計目的・情報圧縮の利点活用）
- ✅ **フィルタリング・絞り込み**: 有効（カテゴリ軸での制限・構造化データとして機能）
- ⚠️ **検索補助・関連発見**: 限定的（直接検索の補完のみ・メイン手段としては不適）
- ❌ **検索の主要手段**: 不適切（情報損失により精度劣化・分類≠検索の原理的限界）

**設計哲学の確立**:
- **分類思考**: 既知カテゴリへの効率的割り当て（タグの得意分野）
- **検索思考**: 未知の関連性や微細な文脈の発見（ベクトル検索の得意分野）
- **役割分担**: タグは「結果の整理」、ベクトル検索は「関連性の発見」

**結論**: タグは「検索の出発点ではなく、検索結果の整理・分類ツール」として活用すべきであり、現行のハイブリッド検索システム（直接ベクトル検索+タグ補助）が最適解として確定。この設計により、それぞれの手法の得意分野を最大限活用できる。
