# settings

## なぜこの実装が存在するか

### 設定データとUI機能の分離
**Problem**: ui_settings.pyでは設定データの保持とUI操作が同一クラスに混在しており、責務が明確でなく、テストやメンテナンスが困難だった。

**Solution**: 設定データを格納するsettings.pyと、UI操作を担当するsettings_ui.pyに分離。設定クラスはデータの保持と基本的な操作のみを担当し、UI関連のライブラリ依存を排除した純粋なデータクラスとして設計。

### 再利用可能な設定クラス設計
**Problem**: UI機能と密結合した設定クラスでは、他のモジュールからの設定値利用や、ユニットテスト時の設定操作が困難だった。

**Solution**: UI関連のライブラリに依存しない純粋なデータクラスとして実装。設定の取得・設定・チェック・フォーマット機能をメソッドとして提供し、どこからでも利用可能な設計とした。

### 設定ロジックの一元管理
**Problem**: 設定の整合性チェック（from<to、min<max）や設定の組み合わせルール（includes/excludes排他、threshold組み合わせ可能）がUI層に散在していた。

**Solution**: 設定クラス内で整合性チェックと組み合わせルールを実装。set_*メソッド内で矛盾する設定の自動削除を行い、データ層で一貫した設定状態を保証する設計とした。

### フィルタリング設定の論理分離
**Problem**: includes/excludesとthreshold系フィルターが混在すると、設定の意図が不明確になり、予期しない検索結果を招く。また、from/to日付設定とユーザー設定の関係性が分かりにくい。

**Solution**: 設定の論理的分離を実装。includes/excludes設定時は他の全設定をクリアし、単独動作とした。threshold設定時はincludes/excludesのみクリアし、threshold同士は組み合わせ可能とした。日付設定ではfrom/toを相互保持しつつ、ユーザー設定とは独立させた。これにより、設定の意図が明確で予測可能な動作を実現した。

### 入力値の矛盾自動解決機能
**Problem**: from/to日付やmin/max値で矛盾する設定（from>to、min>max）が入力された際、エラーで再入力を求めると操作が煩雑になり、ユーザビリティが低下する。

**Solution**: 矛盾検出時の自動解決機能を実装。新しい入力値を優先し、矛盾する既存値を自動削除する方式を採用。例：新しいfrom値がto値以上の場合、to設定を自動削除。この設計により、ユーザーの入力意図を尊重しつつ、論理的に一貫した設定状態を維持できる。

### SearchSettings統合クラスによる設定管理の一元化
**Problem**: UserFilterSettings、DateFilterSettings、TopKSettingsの3つのクラスが分離しており、設定の受け渡しや管理が煩雑になっていた。また、ネットワーク通信でのシリアライズ・デシリアライズ機能が不足していた。

**Solution**: SearchSettingsクラスを新設し、3つの設定クラスを統合管理する設計を採用。to_dict()メソッドで全設定をDict形式にシリアライズし、from_dict()メソッドでDict形式から設定を復元する機能を実装。重複除去は検索結果の質を向上させる基本機能であるため常時有効とし、設定項目から除外。これにより、WebSocket通信での設定送受信と、複数の設定クラスの協調動作を単純化した。

### ユーザー投稿数データの分離による設計改善
**Problem**: UserFilterSettingsがuser_post_countsを内部に保持していたため、設定クラスが大量のユーザーデータを抱え込み、シリアライズ時の通信量増大と設定クラスの肥大化が発生していた。また、user_post_countsは設定データではなく参照データであるにも関わらず、設定と同列に扱われていた。

**Solution**: user_post_countsをUserFilterSettingsから完全に分離し、is_user_allowed()メソッドの引数として渡す設計に変更。SearchEngineがself.user_post_countsとして保持し、フィルタリング時に引数として提供する方式を採用。これにより、設定クラスは純粋な設定値のみを管理し、ユーザーデータはサーバー側でのみ保持される軽量なアーキテクチャを実現。ネットワーク通信量の削減と設定管理の簡素化を同時に達成した。

### バリデーション遅延による安全性と柔軟性の両立
**Problem**: 設定クラス（TopKSettings等）でバリデーションを実行すると、設定値の読み込み・復元・テスト時に予期しない例外が発生し、システムの安定性が損なわれる可能性がある。一方で、不正な値での実行は防ぐ必要がある。

**Solution**: 設定クラスでは純粋に値を保持するだけとし、バリデーションは実際に使用される時点まで遅延させる方針を採用。UI側（settings_ui.py）で入力時制限、サーバー側（twilog_server.py）で使用時制限を実装することで、二重の安全性を確保。設定値の受け渡しや復元時には例外を発生させず、実行時にのみ厳密なバリデーションを行う柔軟性と安全性を両立した設計とした。

### ユーザーフィルタリング設定の詳細表示機能
**Problem**: `format_status()`メソッドでincludes/excludes設定を「includes (3人)」のような件数のみで表示していたため、実際にどのユーザーが設定されているかが分からず、設定内容の確認と調整が困難だった。

**Solution**: 3人以下の場合は全ユーザー名を表示（`includes: user1, user2, user3`）、4人以上の場合は最初の3人と総数を表示（`includes: user1, user2, user3...(5人)`）する詳細表示機能を実装。これにより、search.pyでの検索実行時に現在の設定内容を具体的に確認でき、フィルタリング設定の透明性と調整の利便性が向上。設定ミスの早期発見と適切な修正が可能になった。

### 検索モード設定の統合
**Problem**: ハイブリッド検索モードの組み込みに伴い、検索モード（content、reasoning、summary、average、maximum、minimum）と重み設定（averageモード時のweights）を管理する必要が生じた。これらの設定が既存のSearchSettingsクラスに統合されていないと、設定の受け渡しや管理が煩雑になる。

**Solution**: SearchModeSettingsクラスを新設し、検索モードと重み設定を統合管理する設計を採用。デフォルトモードを「content」とし、重み設定は[1.0, 1.0, 1.0]の均等重みを初期値とした。set_mode()メソッドでaverageモード以外では重みを自動的にクリアし、set_weights()メソッドでaverageモード時のみ重みを正規化して設定する機能を実装。get_weights()メソッドでは均等重み以外の場合のみ重みを返し、contentモードなど重み設定が無意味な場合はNoneを返す。format_status()メソッドで重み設定を含む状態表示を提供。SearchSettingsクラスのmode_settingsとして統合し、シリアライズ・デシリアライズ機能も追加することで、既存の設定管理アーキテクチャと一貫した動作を実現した。

### デフォルトモードの一元管理と適応的設定
**Problem**: デフォルトの検索モードが複数箇所にハードコードされており、変更時の修正漏れが発生しやすい構造だった。また、Search.pyとsettings.pyで異なるデフォルトモードを使用する必要があり、設定の一貫性が確保できなかった。

**Solution**: `DEFAULT_MODE`定数を導入し、デフォルト検索モードを一元管理する設計を採用。SearchModeSettingsのコンストラクタとfrom_dict()メソッドでDEFAULT_MODEを使用することで、デフォルト値の変更が単一箇所で済む保守性を実現。search.pyでは"maximum"、settings.pyでは"content"の異なるDEFAULT_MODEを定義し、各モジュールの要件に応じた適応的なデフォルト値設定を可能にした。これにより、コード変更時の修正箇所を最小化し、モジュール間の設定一貫性を保持した。

### 表示モード設定の統合
**Problem**: 検索結果の表示形式（通常・一覧・詳細）を管理する設定が存在せず、表示モードの切り替えや状態管理が困難だった。また、既存のSearchSettingsクラスに統合されていないと、設定の受け渡しや管理が煩雑になる。

**Solution**: ViewModeSettingsクラスを新設し、表示モード状態を一元管理する設計を採用。デフォルト表示モードを"normal"とし、"normal"（通常）、"list"（一覧）、"detail"（詳細）の3つのモードを管理。set_view_mode()メソッドで有効な表示モードのみを受け付け、不正な値の場合はValueErrorを発生させる入力検証を実装。get_view_mode()メソッドで現在の表示モードを取得し、format_status()メソッドで「通常」「一覧」「詳細」の日本語表示を提供。SearchSettingsクラスのview_modeとして統合し、他の設定クラスと同様の管理構造を実現。`DEFAULT_VIEW_MODE`定数を追加して表示モードのデフォルト値を一元管理し、保守性を向上させた。