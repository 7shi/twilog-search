# settings

## なぜこの実装が存在するか

### 設定データとUI機能の分離
**Problem**: ui_settings.pyでは設定データの保持とUI操作が同一クラスに混在しており、責務が明確でなく、テストやメンテナンスが困難だった。

**Solution**: 設定データを格納するsettings.pyと、UI操作を担当するsettings_ui.pyに分離。設定クラスはデータの保持と基本的な操作のみを担当し、UI関連のライブラリ依存を排除した純粋なデータクラスとして設計。

### 再利用可能な設定クラス設計
**Problem**: UI機能と密結合した設定クラスでは、他のモジュールからの設定値利用や、ユニットテスト時の設定操作が困難だった。

**Solution**: UI関連のライブラリに依存しない純粋なデータクラスとして実装。設定の取得・設定・チェック・フォーマット機能をメソッドとして提供し、どこからでも利用可能な設計とした。

### 設定ロジックの一元管理
**Problem**: 設定の整合性チェック（from<to、min<max）や設定の組み合わせルール（includes/excludes排他、threshold組み合わせ可能）がUI層に散在していた。

**Solution**: 設定クラス内で整合性チェックと組み合わせルールを実装。set_*メソッド内で矛盾する設定の自動削除を行い、データ層で一貫した設定状態を保証する設計とした。

### フィルタリング設定の論理分離
**Problem**: includes/excludesとthreshold系フィルターが混在すると、設定の意図が不明確になり、予期しない検索結果を招く。また、from/to日付設定とユーザー設定の関係性が分かりにくい。

**Solution**: 設定の論理的分離を実装。includes/excludes設定時は他の全設定をクリアし、単独動作とした。threshold設定時はincludes/excludesのみクリアし、threshold同士は組み合わせ可能とした。日付設定ではfrom/toを相互保持しつつ、ユーザー設定とは独立させた。これにより、設定の意図が明確で予測可能な動作を実現した。

### 入力値の矛盾自動解決機能
**Problem**: from/to日付やmin/max値で矛盾する設定（from>to、min>max）が入力された際、エラーで再入力を求めると操作が煩雑になり、ユーザビリティが低下する。

**Solution**: 矛盾検出時の自動解決機能を実装。新しい入力値を優先し、矛盾する既存値を自動削除する方式を採用。例：新しいfrom値がto値以上の場合、to設定を自動削除。この設計により、ユーザーの入力意図を尊重しつつ、論理的に一貫した設定状態を維持できる。

### SearchSettings統合クラスによる設定管理の一元化
**Problem**: UserFilterSettings、DateFilterSettings、TopKSettingsの3つのクラスが分離しており、設定の受け渡しや管理が煩雑になっていた。また、ネットワーク通信でのシリアライズ・デシリアライズ機能が不足していた。

**Solution**: SearchSettingsクラスを新設し、3つの設定クラスを統合管理する設計を採用。to_dict()メソッドで全設定をDict形式にシリアライズし、from_dict()メソッドでDict形式から設定を復元する機能を実装。重複除去は検索結果の質を向上させる基本機能であるため常時有効とし、設定項目から除外。これにより、WebSocket通信での設定送受信と、複数の設定クラスの協調動作を単純化した。

### ユーザー投稿数データの分離による設計改善
**Problem**: UserFilterSettingsがuser_post_countsを内部に保持していたため、設定クラスが大量のユーザーデータを抱え込み、シリアライズ時の通信量増大と設定クラスの肥大化が発生していた。また、user_post_countsは設定データではなく参照データであるにも関わらず、設定と同列に扱われていた。

**Solution**: user_post_countsをUserFilterSettingsから完全に分離し、is_user_allowed()メソッドの引数として渡す設計に変更。SearchEngineがself.user_post_countsとして保持し、フィルタリング時に引数として提供する方式を採用。これにより、設定クラスは純粋な設定値のみを管理し、ユーザーデータはサーバー側でのみ保持される軽量なアーキテクチャを実現。ネットワーク通信量の削減と設定管理の簡素化を同時に達成した。

### バリデーション遅延による安全性と柔軟性の両立
**Problem**: 設定クラス（TopKSettings等）でバリデーションを実行すると、設定値の読み込み・復元・テスト時に予期しない例外が発生し、システムの安定性が損なわれる可能性がある。一方で、不正な値での実行は防ぐ必要がある。

**Solution**: 設定クラスでは純粋に値を保持するだけとし、バリデーションは実際に使用される時点まで遅延させる方針を採用。UI側（settings_ui.py）で入力時制限、サーバー側（twilog_server.py）で使用時制限を実装することで、二重の安全性を確保。設定値の受け渡しや復元時には例外を発生させず、実行時にのみ厳密なバリデーションを行う柔軟性と安全性を両立した設計とした。

### ユーザーフィルタリング設定の詳細表示機能
**Problem**: `format_status()`メソッドでincludes/excludes設定を「includes (3人)」のような件数のみで表示していたため、実際にどのユーザーが設定されているかが分からず、設定内容の確認と調整が困難だった。

**Solution**: 3人以下の場合は全ユーザー名を表示（`includes: user1, user2, user3`）、4人以上の場合は最初の3人と総数を表示（`includes: user1, user2, user3...(5人)`）する詳細表示機能を実装。これにより、search.pyでの検索実行時に現在の設定内容を具体的に確認でき、フィルタリング設定の透明性と調整の利便性が向上。設定ミスの早期発見と適切な修正が可能になった。