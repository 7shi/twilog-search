# settings

## なぜこの実装が存在するか

### 設定データとUI機能の分離
**Problem**: ui_settings.pyでは設定データの保持とUI操作が同一クラスに混在しており、責務が明確でなく、テストやメンテナンスが困難だった。

**Solution**: 設定データを格納するsettings.pyと、UI操作を担当するsettings_ui.pyに分離。設定クラスはデータの保持と基本的な操作のみを担当し、UI関連のライブラリ依存を排除した純粋なデータクラスとして設計。

### 再利用可能な設定クラス設計
**Problem**: UI機能と密結合した設定クラスでは、他のモジュールからの設定値利用や、ユニットテスト時の設定操作が困難だった。

**Solution**: UI関連のライブラリに依存しない純粋なデータクラスとして実装。設定の取得・設定・チェック・フォーマット機能をメソッドとして提供し、どこからでも利用可能な設計とした。

### 設定ロジックの一元管理
**Problem**: 設定の整合性チェック（from<to、min<max）や設定の組み合わせルール（includes/excludes排他、threshold組み合わせ可能）がUI層に散在していた。

**Solution**: 設定クラス内で整合性チェックと組み合わせルールを実装。set_*メソッド内で矛盾する設定の自動削除を行い、データ層で一貫した設定状態を保証する設計とした。

### フィルタリング設定の論理分離
**Problem**: includes/excludesとthreshold系フィルターが混在すると、設定の意図が不明確になり、予期しない検索結果を招く。また、from/to日付設定とユーザー設定の関係性が分かりにくい。

**Solution**: 設定の論理的分離を実装。includes/excludes設定時は他の全設定をクリアし、単独動作とした。threshold設定時はincludes/excludesのみクリアし、threshold同士は組み合わせ可能とした。日付設定ではfrom/toを相互保持しつつ、ユーザー設定とは独立させた。これにより、設定の意図が明確で予測可能な動作を実現した。

### 入力値の矛盾自動解決機能
**Problem**: from/to日付やmin/max値で矛盾する設定（from>to、min>max）が入力された際、エラーで再入力を求めると操作が煩雑になり、ユーザビリティが低下する。

**Solution**: 矛盾検出時の自動解決機能を実装。新しい入力値を優先し、矛盾する既存値を自動削除する方式を採用。例：新しいfrom値がto値以上の場合、to設定を自動削除。この設計により、ユーザーの入力意図を尊重しつつ、論理的に一貫した設定状態を維持できる。