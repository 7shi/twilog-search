# tag_vectorize

## なぜこの実装が存在するか

### タグベクトル化の必要性
**Problem**: タグベースの検索システムでは、タグ間の意味的類似度を計算する必要があるが、テキストのままでは効率的な類似度計算が困難だった。

**Solution**: 全てのタグを事前にベクトル化し、数値計算による高速な類似度計算を可能にするバッチ処理を実装。

### 一括処理による効率化
**Problem**: 個別のタグ検索時に都度ベクトル化すると、レスポンス時間が遅くなり、ユーザー体験が悪化する。

**Solution**: 全タグを事前に一括でベクトル化し、結果をファイルに保存することで、検索時は事前計算済みベクトルを使用する方式を採用。

### タグ一覧ファイルからの直接処理
**Problem**: 以前はTSVファイルからタグを抽出していたが、既にソート済みのタグ一覧ファイルが生成されるようになり、重複処理が発生していた。

**Solution**: tag_dump.pyで生成されるbatch/tags.txtから直接タグを読み込むことで、処理を簡素化し、データフローを最適化した。

### 統一データ形式での保存
**Problem**: タグとベクトルの対応関係が明確でないと、検索結果の解釈が困難になる。

**Solution**: tags.txtの行順序とベクトルの順序を一致させることで、インデックスによる対応関係を保証するアーキテクチャとした。

### 進捗可視化の必要性
**Problem**: 大量のタグ処理には時間がかかり、処理状況が不明だとユーザーが処理停止を疑う。

**Solution**: tqdmを使用したプログレスバー表示により、処理進捗を可視化し、安心して処理完了を待てる仕組みを導入。

### Ruri v3 prefix適用
**Problem**: タグをそのままベクトル化すると、埋め込みモデルが期待する形式と異なり、検索精度が低下する。

**Solution**: Ruri v3の「トピック: 」prefixを付与することで、モデルがタグをトピックとして認識し、より適切なベクトル表現を生成できるようにした。

### コマンドライン制御による柔軟性
**Problem**: 全タグ処理は時間がかかるため、開発・テスト時に少量のデータでの動作確認が困難だった。また、出力ファイル名の制御ができないため、異なる設定での実験が困難だった。

**Solution**: `--limit`オプションによる処理件数制限と、`-o`オプションによる出力ファイル指定を追加し、テスト実行と本番実行を柔軟に切り替えられるようにした。

### ベクトル形状の自動最適化
**Problem**: EmbedClientから返されるベクトルが`[1, 768]`形状で、これをスタックすると`[N, 1, 768]`という無駄な3次元テンソルが生成され、後続処理で形状変換が必要になる。

**Solution**: 保存時に自動的に`squeeze(1)`を適用し、`[N, 768]`の最適化された2次元テンソルとして保存することで、TagReaderでの形状正規化処理を不要にした。