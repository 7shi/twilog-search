# command

## なぜこの実装が存在するか

### コマンドシステムの分離と汎用化
**Problem**: アプリケーションのメインロジックにコマンド処理が直接実装されており、コマンドの追加や変更時にコアロジックと混在してしまい、保守性が低下していた。また、他のアプリケーションでコマンドシステムを再利用することができなかった。

**Solution**: CommandHandlerクラスとして独立したコマンドシステムを実装し、アプリケーションロジックとの完全な分離を実現。デコレーターパターンによる宣言的なコマンド登録機能により、新しいコマンドの追加が容易になった。

### デコレーターによる宣言的コマンド登録
**Problem**: 従来の手動コマンド登録では、コマンド追加時に複数箇所のコードを変更する必要があり、登録忘れやタイポによるバグが発生しやすかった。

**Solution**: `@command(["alias1", "alias2"], "説明")`デコレーターを実装し、関数定義と同時にコマンド登録が自動実行される仕組みを採用。コマンドのエイリアス、説明、実行関数が一箇所に集約され、メンテナンス性が向上した。

### インスタンスベースのコマンドレジストリ
**Problem**: グローバル変数によるコマンド管理では、複数のCommandHandlerインスタンスが同一レジストリを共有してしまい、独立したコマンドセットを持つことができなかった。

**Solution**: `self.command_registry`として各インスタンスが独自のコマンドレジストリを持つ設計に変更。これにより、用途別に異なるコマンドセットを管理でき、システムの柔軟性が向上した。

### execute戻り値による処理制御の明確化
**Problem**: コマンド処理の成否やコマンドとして処理されたかどうかの判定が曖昧で、呼び出し側で適切な制御フローを実装することが困難だった。

**Solution**: `execute`メソッドがbool値を返すことで、コマンドとして処理された場合はTrue（エラー発生時も含む）、通常の検索処理に移行すべき場合はFalseを返す明確な仕様を採用。呼び出し側での条件分岐が簡潔になった。

### コマンド補完機能の統合
**Problem**: コマンド入力時に利用可能なコマンドを覚えていない場合や、タイポを防ぎたい場合に、効率的な入力支援が提供されていなかった。

**Solution**: readlineの補完機能と連携したコマンド補完システムを実装。`get_command_completer`で動的に補完候補を生成し、`setup_completion`でCompletionManagerと統合。Tab補完により利用可能コマンドを即座に確認・入力できる環境を実現した。

### show_helpの外部公開メソッド化
**Problem**: ヘルプ表示機能が内部メソッド（`_show_help`）として実装されていたため、外部からの呼び出しが困難で、ヘルプコマンドの実装時に設計の一貫性が保てなかった。

**Solution**: `show_help`として外部公開メソッドに変更し、コマンド関数からの直接呼び出しを可能にした。登録順でのコマンド表示により、開発者の意図した順序でヘルプが表示され、ユーザビリティが向上した。

### プログラム制御フラグの外部化
**Problem**: `CommandHandler`がプログラム終了フラグを保持していたため、コマンドシステムとアプリケーション制御の責任が混在し、設計の純度が低下していた。また、終了判定のためにCommandHandlerインスタンスの状態をチェックする必要があり、呼び出し側のコードが複雑化していた。

**Solution**: プログラム制御フラグを`CommandHandler`から削除し、アプリケーション側で管理する設計に変更。コマンド実行時は外部のフラグを直接更新し、メインループで参照する方式を採用。これにより、CommandHandlerの責任をコマンドの登録・実行のみに純化し、汎用的なコマンドシステムとしての再利用性を向上させた。