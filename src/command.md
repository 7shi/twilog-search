# command

## なぜこの実装が存在するか

### コマンドシステムの分離と汎用化
**Problem**: アプリケーションのメインロジックにコマンド処理が直接実装されており、コマンドの追加や変更時にコアロジックと混在してしまい、保守性が低下していた。また、他のアプリケーションでコマンドシステムを再利用することができなかった。

**Solution**: CommandHandlerクラスとして独立したコマンドシステムを実装し、アプリケーションロジックとの完全な分離を実現。デコレーターパターンによる宣言的なコマンド登録機能により、新しいコマンドの追加が容易になった。

### デコレーターによる宣言的コマンド登録
**Problem**: 従来の手動コマンド登録では、コマンド追加時に複数箇所のコードを変更する必要があり、登録忘れやタイポによるバグが発生しやすかった。

**Solution**: `@command(["alias1", "alias2"], "説明")`デコレーターを実装し、関数定義と同時にコマンド登録が自動実行される仕組みを採用。コマンドのエイリアス、説明、実行関数が一箇所に集約され、メンテナンス性が向上した。

### インスタンスベースのコマンドレジストリ
**Problem**: グローバル変数によるコマンド管理では、複数のCommandHandlerインスタンスが同一レジストリを共有してしまい、独立したコマンドセットを持つことができなかった。

**Solution**: `self.command_registry`として各インスタンスが独自のコマンドレジストリを持つ設計に変更。これにより、用途別に異なるコマンドセットを管理でき、システムの柔軟性が向上した。

### execute戻り値による処理制御の明確化
**Problem**: コマンド処理の成否やコマンドとして処理されたかどうかの判定が曖昧で、呼び出し側で適切な制御フローを実装することが困難だった。

**Solution**: `execute`メソッドがbool値を返すことで、コマンドとして処理された場合はTrue（エラー発生時も含む）、通常の検索処理に移行すべき場合はFalseを返す明確な仕様を採用。呼び出し側での条件分岐が簡潔になった。

### コマンド補完機能の統合
**Problem**: コマンド入力時に利用可能なコマンドを覚えていない場合や、タイポを防ぎたい場合に、効率的な入力支援が提供されていなかった。

**Solution**: readlineの補完機能と連携したコマンド補完システムを実装。`get_command_completer`で動的に補完候補を生成し、`setup_completion`でCompletionManagerと統合。Tab補完により利用可能コマンドを即座に確認・入力できる環境を実現した。

### show_helpの外部公開メソッド化
**Problem**: ヘルプ表示機能が内部メソッド（`_show_help`）として実装されていたため、外部からの呼び出しが困難で、ヘルプコマンドの実装時に設計の一貫性が保てなかった。

**Solution**: `show_help`として外部公開メソッドに変更し、コマンド関数からの直接呼び出しを可能にした。登録順でのコマンド表示により、開発者の意図した順序でヘルプが表示され、ユーザビリティが向上した。

### プログラム制御フラグの外部化
**Problem**: `CommandHandler`がプログラム終了フラグを保持していたため、コマンドシステムとアプリケーション制御の責任が混在し、設計の純度が低下していた。また、終了判定のためにCommandHandlerインスタンスの状態をチェックする必要があり、呼び出し側のコードが複雑化していた。

**Solution**: プログラム制御フラグを`CommandHandler`から削除し、アプリケーション側で管理する設計に変更。コマンド実行時は外部のフラグを直接更新し、メインループで参照する方式を採用。これにより、CommandHandlerの責任をコマンドの登録・実行のみに純化し、汎用的なコマンドシステムとしての再利用性を向上させた。

### 引数対応とステートレス化
**Problem**: 初期実装では引数を受け取らないコマンドのみに対応しており、`/details 1,5`のような引数付きコマンドが実装できなかった。また、CommandHandlerがインスタンス変数に引数を保存するステートフルな設計により、並行処理時の状態競合のリスクがあった。

**Solution**: 最初のスペースでコマンド名と引数文字列を分離し、`inspect.signature`を使用して関数のパラメータ数を自動判定する仕組みを実装。引数を受け取るハンドラには`func(handler, args_str)`、引数を受け取らないハンドラには`func(handler)`として呼び出すことで、既存コマンドとの互換性を保持。CommandHandlerは完全にステートレスとし、引数の詳細なパース処理は各ハンドラに委任する責任分離を実現。これにより、引数付きコマンドの実装が容易になり、並行処理での安全性を確保した。

### 範囲指定パース機能の統合
**Problem**: 引数付きコマンドで範囲指定（`23-50`）や個別指定（`1,5`）、混合指定（`1-3,7,10-15`）などの複雑な引数パターンを処理する必要があったが、各コマンドで個別に実装すると重複コードが発生し、保守性が低下する懸念があった。

**Solution**: `parse_range_specification`メソッドをCommandHandlerに追加し、範囲指定文字列を統一的に処理する機能を実装。カンマ区切りでの複数指定、ハイフンでの範囲指定、数値の重複除去とソート処理を一元化。エラーハンドリングも統合し、不正な文字列が含まれていても有効な部分のみを抽出して処理を継続。これにより、引数付きコマンドの実装時に一貫したパース処理を利用でき、コードの重複削減と保守性向上を実現した。