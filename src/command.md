# command

## なぜこの実装が存在するか

### コマンドシステムの分離と汎用化
**Problem**: search.pyにコマンド処理ロジックが直接実装されており、コマンドの追加や変更時にメイン検索ロジックと混在してしまい、保守性が低下していた。また、他のアプリケーションでコマンドシステムを再利用することができなかった。

**Solution**: CommandHandlerクラスとして独立したコマンドシステムを実装し、検索ロジックとの完全な分離を実現。デコレーターパターンによる宣言的なコマンド登録機能により、新しいコマンドの追加が容易になった。

### デコレーターによる宣言的コマンド登録
**Problem**: 従来の手動コマンド登録では、コマンド追加時に複数箇所のコードを変更する必要があり、登録忘れやタイポによるバグが発生しやすかった。

**Solution**: `@command(["alias1", "alias2"], "説明")`デコレーターを実装し、関数定義と同時にコマンド登録が自動実行される仕組みを採用。コマンドのエイリアス、説明、実行関数が一箇所に集約され、メンテナンス性が向上した。

### インスタンスベースのコマンドレジストリ
**Problem**: グローバル変数によるコマンド管理では、複数のCommandHandlerインスタンスが同一レジストリを共有してしまい、独立したコマンドセットを持つことができなかった。

**Solution**: `self.command_registry`として各インスタンスが独自のコマンドレジストリを持つ設計に変更。これにより、用途別に異なるコマンドセットを管理でき、システムの柔軟性が向上した。

### execute戻り値による処理制御の明確化
**Problem**: コマンド処理の成否やコマンドとして処理されたかどうかの判定が曖昧で、呼び出し側で適切な制御フローを実装することが困難だった。

**Solution**: `execute`メソッドがbool値を返すことで、コマンドとして処理された場合はTrue（エラー発生時も含む）、通常の検索処理に移行すべき場合はFalseを返す明確な仕様を採用。呼び出し側での条件分岐が簡潔になった。

### コマンド補完機能の統合
**Problem**: コマンド入力時に利用可能なコマンドを覚えていない場合や、タイポを防ぎたい場合に、効率的な入力支援が提供されていなかった。

**Solution**: readlineの補完機能と連携したコマンド補完システムを実装。`get_command_completer`で動的に補完候補を生成し、`setup_completion`でCompletionManagerと統合。Tab補完により利用可能コマンドを即座に確認・入力できる環境を実現した。

### show_helpの外部公開メソッド化
**Problem**: ヘルプ表示機能が内部メソッド（`_show_help`）として実装されていたため、外部からの呼び出しが困難で、ヘルプコマンドの実装時に設計の一貫性が保てなかった。

**Solution**: `show_help`として外部公開メソッドに変更し、コマンド関数からの直接呼び出しを可能にした。登録順でのコマンド表示により、開発者の意図した順序でヘルプが表示され、ユーザビリティが向上した。