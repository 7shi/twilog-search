# ベクトル検索システム

## なぜこの実装が存在するか

### 検索結果の詳細情報取得
**Problem**: ベクトル検索の結果はpost_idと類似度のみで、ユーザーが内容を確認するには別途データアクセスが必要。また、投稿内容なしでは検索結果の妥当性を判断できない。さらに、投稿者情報がないと文脈の理解が困難。

**Solution**: 検索結果のpost_idを使用してCSVデータから投稿内容、タイムスタンプ、URLを一括取得する仕組みを実装。URL解析によりユーザー情報も取得し、見やすい表示形式「ランク: 類似度 ユーザー [日付] URL」を採用した。CSVデータをメモリに保持することで、高速なデータアクセスを実現した。


### 対話的検索インターフェース
**Problem**: 単発の検索では、クエリの調整や結果の比較が困難。また、複数のクエリでの検索パターンを把握しにくい。さらに、予期しない例外と意図的な終了操作を区別する必要がある。

**Solution**: 対話的なループインターフェースを実装。EOFError（Ctrl+D）とKeyboardInterrupt（Ctrl+C）のみを終了操作として処理し、その他の例外は適切に上位に送出する設計とした。これにより、連続した検索でのクエリ精度向上と、デバッグ時の例外情報保持を両立した。

### デフォルト値による簡易起動
**Problem**: 毎回データファイル名を指定するのは煩雑で、特に決まったファイル名を使用する場合は非効率。また、引数指定を忘れやすく、使用性が低下する。

**Solution**: データファイル引数にデフォルト値`twilog.csv`を設定し、省略可能とした。プロジェクトの標準的なファイル名を採用することで、引数なしでの即座起動を可能にし、日常的な使用での利便性を向上させた。

### コマンドヘルプシステムの実装
**Problem**: 対話的なシステムでは利用可能な機能や操作方法をユーザーが把握しにくい。また、間違ったコマンドを入力した際の適切なフィードバックが必要。

**Solution**: `/help`コマンドによるヘルプ表示機能を実装。利用可能な全コマンドと基本的な使用方法を一覧表示する。さらに、存在しないコマンドが入力された際はエラーメッセージとともに自動的にヘルプを表示し、ユーザーが正しい操作方法を即座に確認できる仕組みとした。起動時メッセージでは冗長さを避けるため、`/help`コマンドの存在のみを示し、詳細は実際のヘルプで確認する方式とした。利便性向上のため`/?`をエイリアスとして提供し、短縮入力を可能にした。

### 対話的入力の利便性向上
**Problem**: 対話的な検索システムでは、ユーザーが過去の検索クエリを再利用したい場合や、入力中に編集が必要な場合がある。標準のinput()では履歴機能や編集機能が制限されている。

**Solution**: readlineモジュールをインポートすることで、コマンドライン入力時にヒストリ機能（上下キーでの履歴呼び出し）と行編集機能（左右キーでのカーソル移動、文字挿入・削除）を有効化した。これにより、検索クエリの修正や過去のクエリの再利用が容易になり、対話的検索の効率が向上する。

### richによる検索結果表示の改善  
**Problem**: プレーンテキストでの検索結果表示では、各項目の区別が困難で、長時間の検索セッションでは視認性が低下する。また、クエリごとの結果の区切りが分かりにくく、スクロール時の確認が困難。

**Solution**: richライブラリのPanel機能により各検索結果を個別のパネルで表示し、ヘッダー情報（ランク、類似度、ユーザー、日時、URL）を色分けした。検索結果の末尾にRuleによるセパレーターを表示し、クエリごとの区切りを明確化。これにより、大量の検索結果でも効率的な確認が可能になった。

### 終了コマンドの多様化
**Problem**: Ctrl+CやCtrl+Dによる終了は強制的で、一部のユーザーには直感的でない。また、設定メニュー中での誤った終了操作を避けたいニーズがある。

**Solution**: `/exit`、`/quit`、`/q`コマンドによる穏やかな終了オプションを追加。これにより、ユーザーが意図的にプログラムを終了する際の選択肢を増やし、より直感的な操作を可能にした。従来のCtrl+C/Ctrl+D終了も併存させ、様々な操作習慣に対応した。

### リモート検索アーキテクチャへの完全移行
**Problem**: 従来のローカルモード（torch、SentenceTransformer直接利用）では、search.pyの起動時に85秒の重いライブラリ読み込みが発生し、開発時の頻繁な再起動で生産性が大幅に低下していた。また、埋め込みデータの読み込みとベクトル検索処理により、search.pyが重厚になり保守性が低下していた。

**Solution**: ruri_server.pyのWebSocket API を活用したリモート検索アーキテクチャに完全移行。torch、safetensors、SentenceTransformersライブラリをsearch.pyから完全に削除し、軽量なWebSocketクライアントとして再設計した。検索クエリをruri_server.pyに送信し、分割送信される検索結果（post_id、similarity）を受信する方式を採用。これによりsearch.pyの起動時間を数秒に短縮し、ベクトル処理の複雑さをサーバー側に集約した。フィルタリング処理はクライアント側に残し、サーバー側の変更頻度を抑制してデーモンの再起動コストを最小化した。検索アーキテクチャの分離により、フィルタリングやUI機能に集中できる設計を実現した。

### TwilogClientによる通信統一化
**Problem**: search.pyで直接WebSocket通信を実装していたため、通信処理が重複し、保守性が低下していた。また、WebSocketプロトコルの詳細がsearch.pyに混在し、責任の分離ができていなかった。さらに、サーバータイプの確認処理が不十分で、誤ったサーバーに接続する可能性があった。

**Solution**: twilog_client.pyのTwilogClientクラスを活用し、WebSocket通信を統一化。_test_websocket_connection()ではclient.get_status()を使用してサーバータイプが'TwilogServer'であることを確認し、適切なサーバーへの接続を保証。_search_remote()ではclient.vector_search()メソッドを使用し、通信の詳細をクライアントクラスに委譲。これにより、search.pyはフィルタリングとUI処理に集中でき、WebSocket通信の複雑さを分離した。

### 検索エンジンの分離
**Problem**: search.pyにSearchEngineクラスが含まれていたため、メイン処理とベクトル検索処理が混在し、コードの責務が曖昧になっていた。また、検索エンジンの機能を他の場所から再利用することが困難だった。

**Solution**: SearchEngineクラスをsearch_engine.pyに独立したモジュールとして分離し、単一責任原則に従って検索ロジックのみを担当するクラスとして定義。search.pyは対話的UIとコマンド処理に専念し、検索エンジンはインポートして使用する構造に変更。これにより、検索エンジンの再利用性が向上し、コードの保守性が大幅に改善された。

### フロントエンド専用化による責務の純化
**Problem**: SearchEngineの分離後も、search.pyでSearchEngineインスタンスを直接管理していたため、CSVファイルの読み込みやフィルタリング処理がクライアント側に残存し、サーバー・クライアント分離が不完全だった。また、MCPサーバーでも同様のフィルタリング処理が重複実装されており、機能の一元化ができていなかった。

**Solution**: search.pyからSearchEngineのインポートと管理を完全に削除し、twilog_server.pyのsearch_similarメソッドを使用する純粋なフロントエンドに変更。フィルタリング処理はサーバー側（twilog_server.py + SearchEngine）に一元化し、search.pyはWebSocket通信と結果表示のみに特化。これにより、検索ロジックの重複を解消し、機能変更時の修正箇所を単一化。CSVファイルパス引数も削除し、設定情報もサーバー側で管理する完全分離アーキテクチャを実現した。

### SearchSettings統合による設定管理の統一化
**Problem**: SearchEngineが状態を持つ設計により、複数クライアントからの同時アクセス時に設定が競合する問題があった。また、設定の変更と検索実行が分離していたため、意図しない設定で検索が実行される可能性があった。

**Solution**: SearchEngineをステートレスに再設計し、search()メソッドの引数でSearchSettingsを受け取る方式に変更。SearchSettingsクラスで3つの設定クラス（UserFilterSettings、DateFilterSettings、TopKSettings）を統合管理し、to_dict()/from_dict()によるシリアライズ機能を実装。search.pyではローカル変数として設定を管理し、TwilogClientが設定をシリアライズしてサーバーに送信、TwilogServerがデシリアライズしてSearchEngineに渡す仕組みを構築。これにより、設定と検索の原子性を保証し、並行アクセスでの競合を解消した。

### ユーザー統計情報による設定機能の復活
**Problem**: SearchSettingsがuser_post_countsを必要とするため、初期化時にサーバーからユーザー統計情報を取得する必要があった。また、取得失敗時の適切なエラーハンドリングが必要だった。

**Solution**: WebSocket接続確認後にget_user_stats()でユーザー統計情報を取得し、SearchSettingsの初期化に使用する設計を採用。取得失敗時は即座にエラー終了し、不完全な状態での起動を防止。これにより、フィルタリング機能（/user、/date、/top コマンド）を完全復活させ、対話的な設定変更を可能にした。

### 軽量な設定管理による起動プロセスの簡素化
**Problem**: 前の実装ではSearchSettingsがuser_post_countsを内部保持していたため、クライアント側でユーザー統計情報を取得してSearchSettingsに渡す必要があり、起動プロセスが複雑化していた。また、大量のユーザーデータがクライアント側に保持され、メモリ使用量とネットワーク通信量が増加していた。

**Solution**: user_post_countsをSearchSettingsから分離し、サーバー側（SearchEngine）でのみ管理する設計に変更。クライアント側ではユーザー統計情報の取得処理を完全削除し、SearchSettingsは純粋な設定値のみを管理するようになった。これにより、search.pyの起動プロセスが大幅に簡素化され、WebSocket接続確認後に即座に検索可能な状態になる軽量なクライアントを実現した。

### 検索プロンプトでの制限表示
**Problem**: ユーザーフィルタや日付フィルタが設定されていても、検索プロンプト時にその情報が表示されないため、現在どのような制限で検索が実行されるかユーザーが把握できなかった。

**Solution**: 検索プロンプトの直前に現在の制限を表示する機能を追加。UserFilterSettingsとDateFilterSettingsのformat_status()メソッドを活用し、制限が設定されている場合のみ`[制限] ユーザー: xxx | 日付: xxx`形式で表示。これにより、ユーザーは現在の検索条件を常に把握でき、意図しない制限での検索実行を防げるようになった。

### V|T複合検索の透過的な対応
**Problem**: ベクトル検索とテキスト検索の組み合わせや、テキスト検索のみの実行を、既存のインターフェースを変更せずに提供する必要があった。新しい機能のためにクライアント側の修正を行うと、複数のクライアント（CLI、MCP）で同期的な変更が必要になり、保守性が低下する懸念があった。

**Solution**: サーバー側（TwilogServer）でのクエリ再解釈により、クライアント側の修正なしにV|T複合検索機能を実現。`parse_pipeline_query`による構文解析をサーバー側で実行し、`機械学習`（ベクトル検索）、`| "hello world" -spam`（テキスト検索のみ）、`機械学習 | -spam`（複合検索）を統一的に処理。クライアントは従来通りクエリ文字列を送信するだけで、サーバー側が自動的に適切な検索方式を選択する透過的なアーキテクチャを採用した。

### ユーザーフィルタリング設定時の候補表示機能
**Problem**: `/user`コマンドでincludes/excludesを設定する際、存在しないユーザー名を入力した場合、そのまま設定されてしまい、検索結果が空になる問題があった。

**Solution**: `suggest_users`機能を統合し、存在しないユーザー名入力時に類似ユーザー候補を表示する機能を実装。詳細な実装内容は [settings_ui.md](./settings_ui.md#ユーザー候補選択機能の統合) を参照。

### 検索モード選択機能の統合
**Problem**: ハイブリッド検索システムの最適化により、6種類の検索モード（content、reasoning、summary、average、maximum、minimum）と重み設定機能が利用可能になったが、search.pyでこれらの機能を選択・利用する手段が不足していた。

**Solution**: `/mode`コマンドを追加し、`show_mode_menu`による検索モード選択機能を実装。SearchSettingsクラスにSearchModeSettingsを統合し、モード設定と重み設定を統一管理。検索実行時は`search_settings.mode_settings.get_mode()`と`search_settings.mode_settings.get_weights()`を取得し、TwilogClientの`search_similar`メソッドにmode/weights引数として渡す設計を採用。制限表示エリアにモード情報を追加し、デフォルトの「average」以外の場合は`[制限] モード: maximum`のように表示。数字キーショートカットと選択即完了の操作フローにより、効率的なモード変更を実現。詳細なUI設計は [docs/20250716-menu.md](../docs/20250716-menu.md) を参照。

### 適応的初期モード設定
**Problem**: reasoningやsummaryデータが利用可能な場合でも、デフォルトでcontentモードが選択されるため、ユーザーが手動で高性能なハイブリッド検索モードに切り替える必要があった。また、利用可能なデータに応じた最適なモード選択が自動化されていなかった。

**Solution**: 接続確認時に`get_status`の結果を取得し、`data_stats`の`total_summaries`値を確認する方式を採用。`total_summaries > 0`の場合はreasoningとsummaryデータが利用可能と判断し、初期モードを自動的に`maximum`に設定。それ以外の場合は従来通り`DEFAULT_MODE`（content）を使用。これにより、利用可能なデータに応じて最適な検索モードが自動選択され、ユーザーは即座に最高性能での検索を開始できるようになった。

### 検索結果表示のレイアウト改善
**Problem**: 検索結果のヘッダー情報（ランク、類似度、ユーザー、日時）が長い一行で表示されており、可読性が低下していた。また、URLがヘッダーに含まれるとさらに長くなり、視認性が悪化していた。さらに、タグ情報がある場合の表示方法が定義されていなかった。

**Solution**: ヘッダー情報の構築を要素ごとに分割し、コメントによる可読性向上を実現。URLをPanelの`subtitle`パラメータに移動し、右寄せ表示でヘッダーをすっきりさせた。タグ情報は`bright_magenta`色でヘッダーに表示し、暗いターミナルでも視認性を確保。これにより、検索結果の各要素が明確に区別され、情報の把握が容易になった。

### ユーザー名Tab補完機能の統合
**Problem**: `/user`コマンドでユーザー名入力時に、正確なユーザー名を覚えていない場合やタイポが発生しやすい場合に、入力効率が低下していた。既存の類似ユーザー提案機能はあるが、入力中のリアルタイム支援がなく、ユーザビリティが限定的だった。

**Solution**: `client.get_user_list()`でサーバーから全ユーザー一覧を取得し、`show_user_filter_menu`の第3引数として渡す仕組みを実装。取得エラー時はNoneを渡すことで、補完機能なしで通常の入力処理を継続。これにより、入力中のTab補完と入力後の類似ユーザー提案を組み合わせた二段階ユーザー支援システムを実現し、ユーザー名入力の効率と正確性を大幅に向上させた。

### UserInfoクラスによるユーザー情報管理の一元化
**Problem**: ユーザー名補完機能とsuggest_users機能が個別に実装されており、ユーザー情報の管理が分散していた。また、user_listが取得できれば外部で処理できるsuggest_users機能がサーバー・クライアント間通信を必要とし、非効率だった。

**Solution**: UserInfoクラスを導入し、ユーザー情報の一元管理を実現。起動時に`client.get_user_list()`で取得したユーザー一覧を`UserInfo(user_list)`でインスタンス化し、`show_user_filter_menu(search_settings.user_filter, user_info)`の形でUserInfoインスタンスを直接渡す設計に変更。UserInfoクラス内でuser_completer（Tab補完）とsuggest_users（類似ユーザー提案）の両機能を提供し、settings_ui.pyが内部でこれらを使い分ける。これにより、ユーザー情報の一元管理と処理効率の向上を両立し、サーバー・クライアント間通信を削減した。

### 検索結果ページネーション機能の実装
**Problem**: 検索結果が大量にある場合、設定したtop_k件を超える結果を確認できず、情報の取りこぼしが発生していた。また、検索のたびに同じ結果を再取得するため、サーバー負荷とレスポンス時間が課題となっていた。

**Solution**: 検索実行時に常に100件取得し、内部でlast_search_results、current_display_index、last_queryを管理するページネーション機能を実装。初回検索時は最初のtop_k件のみ表示し、/nextコマンドで次のtop_k件を順次表示する仕組みを採用。show_results関数でstart_index、top_k、total_countを管理し、表示範囲（例：1-10/100件）を明示。これにより、1回の検索で大量の結果を効率的に閲覧でき、サーバー負荷を削減しながらユーザーの情報取得効率を向上させた。

### コマンドシステムの分離と統一化
**Problem**: 検索アプリケーション内のコマンド処理ロジック（/help、/user、/date、/top、/mode、/next、/exit等）がmain関数に直接実装されており、40行以上のif-elif文で処理されていた。新しいコマンドの追加時に複数箇所の修正が必要で、コマンド処理ロジックの再利用が困難だった。

**Solution**: CommandHandlerクラスとcommand.pyを新設し、@commandデコレーターによる宣言的なコマンド登録システムを実装。各コマンド関数は`@command(["alias1", "alias2"], "説明")`で登録され、`command_handler.execute(query)`で統一的に実行される設計に変更。コマンド補完機能（Tab補完）も統合し、/入力時に利用可能コマンドが自動補完される。検索結果状態管理（last_search_results、current_display_index、last_query）をグローバル変数化し、各コマンド関数から直接参照・更新することで、CommandHandlerの汎用性を維持。これにより、main関数のコマンド処理を数行に簡約化し、新コマンドの追加が関数定義だけで完結する拡張性を実現した。
