# ベクトル検索システム

## なぜこの実装が存在するか

### 分割ファイル読み込みの効率化
**Problem**: 226個のsafetensorsファイルを個別に読み込むと、メモリ使用量が予測しにくく、また検索時の性能が不安定になる。また、大量ファイルの読み込み時間が長く、進捗が見えない問題がある。

**Solution**: 起動時に全ファイルを一度に読み込み、メモリ上で統合する方式を採用。tqdmによる進捗表示により、ユーザーが読み込み状況を把握可能にした。検索時は単一のテンソルに対してコサイン類似度計算を行うため、一貫した高速検索を実現した。

### 検索結果の詳細情報取得
**Problem**: ベクトル検索の結果はpost_idと類似度のみで、ユーザーが内容を確認するには別途データベースアクセスが必要。また、投稿内容なしでは検索結果の妥当性を判断できない。さらに、投稿者情報がないと文脈の理解が困難。

**Solution**: 検索結果のpost_idを使用してSQLiteから投稿内容、タイムスタンプ、URLを一括取得する仕組みを実装。user_postsテーブルとのLEFT JOINによりユーザー情報も取得し、見やすい表示形式「ランク: 類似度 ユーザー [日付] URL」を採用した。データベース接続をインスタンスで保持し、毎回の接続コストを削減した。

### Ruri3モデルの一貫性確保
**Problem**: ベクトル化時とベクトル検索時で適切なプレフィックスを使用しなければ、意味的類似度の計算精度が低下する。

**Solution**: ベクトル化時の「検索文書: 」に対応する「検索クエリ: 」プレフィックスを使用。Ruri3モデルの設計意図に沿った一貫性のあるベクトル化を実現した。

### 対話的検索インターフェース
**Problem**: 単発の検索では、クエリの調整や結果の比較が困難。また、複数のクエリでの検索パターンを把握しにくい。さらに、予期しない例外と意図的な終了操作を区別する必要がある。

**Solution**: 対話的なループインターフェースを実装。EOFError（Ctrl+D）とKeyboardInterrupt（Ctrl+C）のみを終了操作として処理し、その他の例外は適切に上位に送出する設計とした。これにより、連続した検索でのクエリ精度向上と、デバッグ時の例外情報保持を両立した。

### メモリ効率とパフォーマンスのバランス
**Problem**: 22万件のベクトルデータを全てメモリに保持すると約860MBのメモリ使用となり、環境によっては負荷が高い。一方、毎回ファイルから読み込むと検索速度が著しく低下する。

**Solution**: 起動時の一括読み込み方式を採用。初期化時間は長くなるが、検索時は数ミリ秒での高速レスポンスを実現。対話的な検索では初期化コストを十分に回収できる設計とした。

### ユーザーフィルタリング機能の必要性
**Problem**: 22万件の投稿に対して検索を行う際、特定のユーザーのみ、または特定のユーザーを除外した検索を行いたい場合がある。また、投稿数の多いユーザーや少ないユーザーに絞った検索ニーズもある。

**Solution**: 辞書ベースのフィルタリング設定を実装。
- {}: フィルタリングなし（すべてのユーザー）
- {"includes": [...]}: 指定ユーザーのみを対象
- {"excludes": [...]}: 指定ユーザーを除外
- {"threshold_min": N}: 投稿数N以上のユーザーのみ
- {"threshold_max": N}: 投稿数N以下のユーザーのみ
閾値設定では事前にユーザーリスト変換せず、SQLサブクエリで動的に条件適用する方式とした。空の辞書による無効状態の判定により、シンプルで直感的な設計を実現した。

### 対話的フィルタリング設定の実装
**Problem**: コマンドライン引数でフィルタリング設定を行うと、検索セッション中に設定変更ができない。また、複数の設定パターンを試行錯誤するのが困難。

**Solution**: `/user`コマンドによる対話的フィルタリング設定メニューを実装。検索セッション中にリアルタイムで設定変更が可能で、設定内容の確認や取り消しも容易にした。効率的なフィルタリングのため、起動時にuser_postsテーブル全件をメモリにロードし、post_id→userのマップと投稿数集計を事前作成する方式とした。

### 例外処理の分離設計
**Problem**: フィルタリング設定メニューでKeyboardInterrupt（Ctrl+C）をキャッチすると、ユーザーが意図的にプログラム全体を終了させたい場合でも設定メニューレベルで処理されてしまう。

**Solution**: フィルタリング設定ではEOFError（Ctrl+D）のみをキャッチし、KeyboardInterrupt（Ctrl+C）は上位に伝播させる設計を採用。これにより、設定メニュー内でのキャンセルは穏やかに処理し、プログラム全体の終了は確実に実行される。

### 表示件数の動的設定機能
**Problem**: 検索内容や用途によって必要な結果数が変わるため、セッション中に表示件数を調整したいニーズがある。探索的な検索では少数、網羅的な調査では多数の結果が必要になる。

**Solution**: `/top`コマンドによる対話的な表示件数設定を実装。現在値を画面に表示してから入力を求め、設定変更は即座に反映される。以降の検索で新しい件数が適用される。

### デフォルト値による簡易起動
**Problem**: 毎回データベースファイル名を指定するのは煩雑で、特に決まったファイル名を使用する場合は非効率。また、引数指定を忘れやすく、使用性が低下する。

**Solution**: データベースファイル引数にデフォルト値`twilog.db`を設定し、省略可能とした。プロジェクトの標準的なファイル名を採用することで、引数なしでの即座起動を可能にし、日常的な使用での利便性を向上させた。

### コマンドヘルプシステムの実装
**Problem**: 対話的なシステムでは利用可能な機能や操作方法をユーザーが把握しにくい。また、間違ったコマンドを入力した際の適切なフィードバックが必要。

**Solution**: `/help`コマンドによるヘルプ表示機能を実装。利用可能な全コマンドと基本的な使用方法を一覧表示する。さらに、存在しないコマンドが入力された際はエラーメッセージとともに自動的にヘルプを表示し、ユーザーが正しい操作方法を即座に確認できる仕組みとした。起動時メッセージでは冗長さを避けるため、`/help`コマンドの存在のみを示し、詳細は実際のヘルプで確認する方式とした。利便性向上のため`/?`をエイリアスとして提供し、短縮入力を可能にした。

### ジェネレーター型検索アーキテクチャ
**Problem**: フィルタリングや重複除去により、どこまで処理を進める必要があるかが事前に予測できない。一括処理では無駄な処理が発生し、事前最適化も困難になる。また、大量データを一度にメモリに保持すると効率が悪い。

**Solution**: 検索処理をジェネレーター型に設計し、類似度順に投稿を1件ずつ処理する方式を採用。フィルタリング、重複除去、投稿内容取得を順次実行し、利用側で必要な件数に達した時点で処理を終了する。これにより、無駄な処理を削減し、メモリ効率も向上させた。正確性を重視し、パフォーマンス最適化よりも確実な結果取得を優先した設計とした。

### 対話的入力の利便性向上
**Problem**: 対話的な検索システムでは、ユーザーが過去の検索クエリを再利用したい場合や、入力中に編集が必要な場合がある。標準のinput()では履歴機能や編集機能が制限されている。

**Solution**: readlineモジュールをインポートすることで、コマンドライン入力時にヒストリ機能（上下キーでの履歴呼び出し）と行編集機能（左右キーでのカーソル移動、文字挿入・削除）を有効化した。これにより、検索クエリの修正や過去のクエリの再利用が容易になり、対話的検索の効率が向上する。

### 検索結果の視認性向上
**Problem**: 検索結果の表示において、ヘッダー情報（ランク、類似度、ユーザー名、日付、URL）と投稿内容の区別が困難で、結果の把握が困難になる。また、表示件数が変動した際にランク番号の桁揃えが不統一になり、見た目が整わない。

**Solution**: llm7shiモジュールのbold関数を使用してヘッダー行を太字表示し、投稿内容との視覚的な区別を明確にした。また、ランク番号の表示幅を`top_k`の桁数に基づいて動的に調整することで、設定された表示件数に応じた適切な桁揃えを実現した。これにより、検索結果の可読性が向上し、多件数表示時でも整った見た目を維持できる。

### RT投稿の重複除去機能
**Problem**: RTによって同じユーザーが同じ内容を複数回投稿した場合、検索結果に重複する投稿が表示される。これにより、実質的に同じ内容の投稿が検索結果を占有し、多様性のある結果を得られない問題が発生する。

**Solution**: 検索処理中に(user, content)の組み合わせをキーとした重複チェックを実装。同じユーザーが同じ内容を投稿している場合、日付が古い方の投稿を優先して表示する方式を採用した。これにより、RTによる重複投稿を自動的に統合し、より多様で有用な検索結果を提供できる。投稿内容の取得は必要時のみ行い、パフォーマンスへの影響を最小限に抑えた。

### 日付フィルタリング機能
**Problem**: 時系列での分析や特定期間の投稿に限定した検索のニーズがある。ユーザーフィルタリングだけでは、時間軸での絞り込みができず、検索の精度や有用性が制限される。また、日付入力の形式が統一されていないと、使いやすさが低下する。

**Solution**: `/date`コマンドによる対話的な日付フィルタリング機能を実装。YYYYMMDD形式（例：20230101）とY-M-D形式（例：2023-1-1）の両方をサポートし、柔軟な日付入力を可能にした。
- {}: フィルタリングなし（全期間）
- {"from": timestamp}: 開始日時のみ指定
- {"to": timestamp}: 終了日時のみ指定  
- {"from": timestamp, "to": timestamp}: 期間指定
検索処理では日付チェックをユーザーフィルタリングの後に実行し、効率的な絞り込みを実現。空の辞書による無効状態の判定により、ユーザーフィルタリングと統一された直感的な設計を採用した。

### TUIライブラリによる操作性向上
**Problem**: 従来の数字入力による選択方式では、選択肢を確認してから数字を入力する必要があり、操作が煩雑。また、Ctrl+Cによる強制終了は誤操作を招きやすく、設定途中での穏やかなキャンセルが困難。

**Solution**: simple-term-menuライブラリを採用し、カーソルキーによる直感的な選択とEscキーによるキャンセルを実現。角括弧形式（[1], [2]...）により数字キーでの直接選択も可能とし、従来の操作性を保ちつつUI向上を図った。richライブラリにより色付きの入力プロンプトとエラーメッセージを実装し、視認性を大幅に改善した。

### richによる検索結果表示の改善  
**Problem**: プレーンテキストでの検索結果表示では、各項目の区別が困難で、長時間の検索セッションでは視認性が低下する。また、クエリごとの結果の区切りが分かりにくく、スクロール時の確認が困難。

**Solution**: richライブラリのPanel機能により各検索結果を個別のパネルで表示し、ヘッダー情報（ランク、類似度、ユーザー、日時、URL）を色分けした。検索結果の末尾にRuleによるセパレーターを表示し、クエリごとの区切りを明確化。これにより、大量の検索結果でも効率的な確認が可能になった。

### 設定値のデフォルト表示機能
**Problem**: フィルタリング設定の変更時に、現在の設定値が分からないため、意図しない変更や設定の重複入力が発生する。特にthresholdや日付設定では、既存値からの微調整が困難。

**Solution**: richのPrompt機能により、既存設定がある場合のみデフォルト値として表示する方式を実装。未設定時はデフォルト値なしでEnterキーによるキャンセルを可能にした。これにより、既存設定の確認と効率的な編集を両立し、誤操作を防止した。

### フィルタリング設定の論理分離
**Problem**: includes/excludesとthreshold系フィルターが混在すると、設定の意図が不明確になり、予期しない検索結果を招く。また、from/to日付設定とユーザー設定の関係性が分かりにくい。

**Solution**: 設定の論理的分離を実装。includes/excludes設定時は他の全設定をクリアし、単独動作とした。threshold設定時はincludes/excludesのみクリアし、threshold同士は組み合わせ可能とした。日付設定ではfrom/toを相互保持しつつ、ユーザー設定とは独立させた。これにより、設定の意図が明確で予測可能な動作を実現した。

### 入力値の整合性検証機能
**Problem**: threshold設定で下限>上限、日付設定でfrom>toの矛盾した入力が可能で、検索結果が空になる原因となる。また、無効な日付形式の入力によるエラーが発生する。

**Solution**: 入力時の整合性チェック機能を実装。threshold設定では下限<上限、日付設定ではfrom<toの制約を設け、違反時は赤色のエラーメッセージとともに再入力を求める。日付形式の検証も追加し、無効な入力を事前に排除。これにより、論理的に一貫した設定のみが受け入れられ、予期しない空結果を防止した。

### 終了コマンドの多様化
**Problem**: Ctrl+CやCtrl+Dによる終了は強制的で、一部のユーザーには直感的でない。また、設定メニュー中での誤った終了操作を避けたいニーズがある。

**Solution**: `/exit`、`/quit`、`/q`コマンドによる穏やかな終了オプションを追加。これにより、ユーザーが意図的にプログラムを終了する際の選択肢を増やし、より直感的な操作を可能にした。従来のCtrl+C/Ctrl+D終了も併存させ、様々な操作習慣に対応した。

### readline競合問題の根本解決
**Problem**: rich.promptライブラリとreadlineライブラリの競合により、バックスペースキーで全文字が削除される致命的な問題と、カーソルキー移動が無効化される問題が発生していた。また、標準readlineでは日本語入力時に文字化けや表示崩れが起きる環境依存問題があった。

**Solution**: gnureadlineライブラリを最優先で読み込み、フォールバックで標準readlineを使用する方式を採用。rich.promptを完全に排除し、gnureadline + 標準input()の組み合わせに変更した。これにより、日本語入力、カーソルキー移動、バックスペース削除が全て正常動作し、環境依存問題も解決した。

### 安全な入力システムの構築
**Problem**: rich.promptの除去により、バリデーション機能や統一されたエラーハンドリングが失われ、入力処理の品質低下が懸念された。

**Solution**: `safe_text_input()`と`safe_number_input()`関数を実装し、バリデーション機能、デフォルト値表示、統一されたエラーハンドリング（Ctrl+C/Ctrl+D対応）を提供。rich.promptと同等の機能性を維持しながら、readline競合問題を完全に回避した。入力関数の仕様を統一し、保守性も向上させた。

### ハイブリッドUI構成の採用
**Problem**: 単一ライブラリでは全ての要件（Escキーキャンセル、日本語対応、美しい表示、安定したテキスト入力）を満たすことができなかった。

**Solution**: 最終的にハイブリッド構成を採用：
- **gnureadline + 標準input()**: テキスト入力（日本語・カーソルキー・バックスペース完全対応）
- **simple_term_menu**: メニュー選択（Escキーキャンセル対応）
- **rich表示**: 検索結果の美しい表示（パネル・色付け・ルール）
この組み合わせにより、各ライブラリの強みを活かしつつ弱点を回避し、全ての要件を満たす安定したシステムを実現した。

### readline履歴の分離管理
**Problem**: メインの検索クエリ入力と設定メニューでの入力で履歴が共有されるため、検索クエリを呼び出したい時に設定値の履歴が混入し、使いづらくなる問題があった。

**Solution**: HistoryManagerクラスを実装し、コンテキスト別の履歴管理を実現。`main`（検索クエリ）と`config`（設定入力）の履歴を分離し、各入力場面で適切な履歴のみが利用可能になるよう設計した。これにより、検索クエリ入力時は過去の検索履歴のみ、設定入力時は設定関連の履歴のみが表示され、操作効率が向上した。

### 設定メニューの操作一貫性設計
**Problem**: 設定メニューでの操作が統一されておらず、ユーザーが操作方法を覚えにくい。また、キャンセルと戻るの概念が混在し、意図しない動作を招く可能性があった。

**Solution**: 全設定メニューで統一された操作体系を採用：
- **Ctrl+D/Ctrl+C**: 何も変更せずメニューに戻る
- **無入力+無設定**: 何も聞かずメニューに戻る  
- **無入力+設定あり**: 消去確認後メニューに戻る
- **Escキー**: 「戻る」表記で穏やかにメニュー終了
設定の種類に応じて適切な終了動作を採用：排他的設定（includes/excludes）は設定後即座に終了、両立可能設定（from/to、min/max）は設定後メニューに戻る。これにより、連続設定が可能で直感的な操作を実現した。

### 入力値の矛盾自動解決機能
**Problem**: from/to日付やmin/max値で矛盾する設定（from>to、min>max）が入力された際、エラーで再入力を求めると操作が煩雑になり、ユーザビリティが低下する。

**Solution**: 矛盾検出時の自動解決機能を実装。新しい入力値を優先し、矛盾する既存値を自動削除する方式を採用。例：新しいfrom値がto値以上の場合、to設定を自動削除。削除時は黄色のメッセージで通知し、現在の設定状況を表示。この設計により、ユーザーの入力意図を尊重しつつ、論理的に一貫した設定状態を維持できる。

### yes/no選択の標準化
**Problem**: 設定削除確認など、二択の選択場面で統一されたインターフェースがなく、実装の一貫性が保てない問題があった。

**Solution**: `yes_no_menu()`関数を実装し、simple-term-menuを使用した統一された「はい」「いいえ」選択機能を提供。デフォルト選択の指定、キャンセル対応、戻り値の標準化（True/False/None）により、全ての確認場面で一貫した操作性を実現した。これにより、コードの保守性向上と操作の統一感を両立した。

### 入力処理機能のモジュール分離
**Problem**: search.pyに入力処理機能（HistoryManager、safe_text_input等）が混在し、コードが肥大化していた。また、他のモジュールから再利用できず、機能の重複実装が発生する可能性があった。

**Solution**: 入力処理機能をsafe_inputモジュールに分離し、コードの責任を明確化した。HistoryManager、safe_text_input、safe_number_input、safe_date_input、yes_no_menuを独立したモジュールとして実装。これにより、search.pyの行数を約300行削減し、入力処理の再利用性と保守性を向上させた。

### 履歴コンテキストの項目別分離
**Problem**: 全ての設定入力で同一の履歴コンテキストを使用していたため、異なる種類の入力値が混在し、履歴機能の有用性が低下していた。

**Solution**: 入力項目ごとに個別の履歴コンテキストを割り当てる方式を採用。「user」（ユーザー名関連）、「threshold」（投稿数閾値）、「top_k」（表示件数）、「date_input」（日付入力）に分離し、同種の設定では履歴を共有する設計とした。これにより、過去の入力履歴がより適切に再利用され、設定効率が向上した。

### 入力関数のhistory引数必須化
**Problem**: 履歴管理が任意だった場合、開発者が履歴コンテキストの指定を忘れ、意図しない履歴の混在が発生する可能性があった。

**Solution**: 全ての入力関数でhistory引数を必須とし、明示的な履歴コンテキスト指定を強制する設計を採用。これにより、履歴の適切な分離が保証され、開発者の指定忘れによるバグを防止した。

### リモート検索アーキテクチャへの完全移行
**Problem**: 従来のローカルモード（torch、SentenceTransformer直接利用）では、search.pyの起動時に85秒の重いライブラリ読み込みが発生し、開発時の頻繁な再起動で生産性が大幅に低下していた。また、埋め込みデータの読み込みとベクトル検索処理により、search.pyが重厚になり保守性が低下していた。

**Solution**: ruri_server.pyのWebSocket API を活用したリモート検索アーキテクチャに完全移行。torch、safetensors、SentenceTransformersライブラリをsearch.pyから完全に削除し、軽量なWebSocketクライアントとして再設計した。検索クエリをruri_server.pyに送信し、分割送信される検索結果（post_id、similarity）を受信する方式を採用。これによりsearch.pyの起動時間を数秒に短縮し、ベクトル処理の複雑さをサーバー側に集約した。フィルタリング処理はクライアント側に残し、サーバー側の変更頻度を抑制してデーモンの再起動コストを最小化した。検索アーキテクチャの分離により、フィルタリングやUI機能に集中できる設計を実現した。

### TwilogClientによる通信統一化
**Problem**: search.pyで直接WebSocket通信を実装していたため、通信処理が重複し、保守性が低下していた。また、WebSocketプロトコルの詳細がsearch.pyに混在し、責任の分離ができていなかった。さらに、サーバータイプの確認処理が不十分で、誤ったサーバーに接続する可能性があった。

**Solution**: twilog_client.pyのTwilogClientクラスを活用し、WebSocket通信を統一化。_test_websocket_connection()ではclient.get_status()を使用してサーバータイプが'TwilogServer'であることを確認し、適切なサーバーへの接続を保証。_search_remote()ではclient.vector_search()メソッドを使用し、通信の詳細をクライアントクラスに委譲。これにより、search.pyはフィルタリングとUI処理に集中でき、WebSocket通信の複雑さを分離した。

### データベースアクセス層の分離
**Problem**: search.pyが700行を超える巨大なファイルとなり、データベースアクセス機能（_load_user_data()、_get_post_content()）とUI・フィルタリング機能が混在していた。これにより、コードの理解と保守が困難になり、データベースアクセス機能の再利用も困難だった。

**Solution**: データベースアクセス機能をdata_sqlite.pyのTwilogDataAccessクラスに分離し、依存関係の注入パターンを採用。search.pyは初期化時にTwilogDataAccessインスタンスを生成し、load_user_data()とget_post_content()メソッドを通じてデータベースにアクセスする。これにより、search.pyは約50行削減され、データベースアクセス機能の再利用性が向上した。責任の分離により、search.pyはフィルタリングとUI処理に専念し、データベース操作の複雑さを分離した。

### CSVベースデータアクセスへの移行
**Problem**: SQLiteベースのデータアクセスでは、データベース構築プロセス（conv.py、extract_users.py等）が必要で、セットアップが複雑だった。22万件程度のデータでは、データベースの利点よりも構築コストの方が高く、シンプルな検索用途には過剰な仕組みだった。

**Solution**: data_csv.pyによるCSVベースのデータアクセスに移行。twilog.csvを直接メモリに読み込み、extract_users.pyのURL解析ロジックを統合することで、外部ファイル依存を完全に排除した。data_sqlite.pyと完全に同じインターフェースを提供し、ドロップイン置換を実現。これにより、データベース構築プロセスが不要になり、CSVファイルのみでの即座検索が可能になった。デフォルトファイル名をtwilog.csvに変更し、CSVベースアーキテクチャを標準とした。

### 設定とUI機能の分離
**Problem**: search.pyが設定UI機能（ユーザーフィルタリング、日付フィルタリング、表示件数設定）とメイン検索機能を同一ファイルに実装していたため、コードが複雑になり保守性が低下していた。また、設定ロジックが散在し、設定の一貫性確保が困難だった。

**Solution**: 設定データをsettings.py、UI機能をsettings_ui.pyに分離し、設定ごとに専用のクラス（UserFilterSettings、DateFilterSettings、TopKSettings）を作成。設定状態と操作を一元管理する設計を採用し、search.pyは検索機能に専念できるようにした。さらに、1行ラッパー関数（_is_user_allowed、_is_date_allowed、設定メニュー関数）をインライン展開して廃止し、コードの複雑性を削減した。これにより、設定とUI機能の責任が明確化され、再利用性と保守性が向上した。
