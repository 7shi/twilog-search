# ベクトル検索システム

## なぜこの実装が存在するか

### 検索結果の詳細情報取得
**Problem**: ベクトル検索の結果はpost_idと類似度のみで、ユーザーが内容を確認するには別途データアクセスが必要。また、投稿内容なしでは検索結果の妥当性を判断できない。さらに、投稿者情報がないと文脈の理解が困難。

**Solution**: 検索結果のpost_idを使用してCSVデータから投稿内容、タイムスタンプ、URLを一括取得する仕組みを実装。URL解析によりユーザー情報も取得し、見やすい表示形式「ランク: 類似度 ユーザー [日付] URL」を採用した。CSVデータをメモリに保持することで、高速なデータアクセスを実現した。


### 対話的検索インターフェース
**Problem**: 単発の検索では、クエリの調整や結果の比較が困難。また、複数のクエリでの検索パターンを把握しにくい。さらに、予期しない例外と意図的な終了操作を区別する必要がある。

**Solution**: 対話的なループインターフェースを実装。EOFError（Ctrl+D）とKeyboardInterrupt（Ctrl+C）のみを終了操作として処理し、その他の例外は適切に上位に送出する設計とした。これにより、連続した検索でのクエリ精度向上と、デバッグ時の例外情報保持を両立した。

### デフォルト値による簡易起動
**Problem**: 毎回データファイル名を指定するのは煩雑で、特に決まったファイル名を使用する場合は非効率。また、引数指定を忘れやすく、使用性が低下する。

**Solution**: データファイル引数にデフォルト値`twilog.csv`を設定し、省略可能とした。プロジェクトの標準的なファイル名を採用することで、引数なしでの即座起動を可能にし、日常的な使用での利便性を向上させた。

### コマンドヘルプシステムの実装
**Problem**: 対話的なシステムでは利用可能な機能や操作方法をユーザーが把握しにくい。また、間違ったコマンドを入力した際の適切なフィードバックが必要。

**Solution**: `/help`コマンドによるヘルプ表示機能を実装。利用可能な全コマンドと基本的な使用方法を一覧表示する。さらに、存在しないコマンドが入力された際はエラーメッセージとともに自動的にヘルプを表示し、ユーザーが正しい操作方法を即座に確認できる仕組みとした。起動時メッセージでは冗長さを避けるため、`/help`コマンドの存在のみを示し、詳細は実際のヘルプで確認する方式とした。利便性向上のため`/?`をエイリアスとして提供し、短縮入力を可能にした。

### 対話的入力の利便性向上
**Problem**: 対話的な検索システムでは、ユーザーが過去の検索クエリを再利用したい場合や、入力中に編集が必要な場合がある。標準のinput()では履歴機能や編集機能が制限されている。

**Solution**: readlineモジュールをインポートすることで、コマンドライン入力時にヒストリ機能（上下キーでの履歴呼び出し）と行編集機能（左右キーでのカーソル移動、文字挿入・削除）を有効化した。これにより、検索クエリの修正や過去のクエリの再利用が容易になり、対話的検索の効率が向上する。

### richによる検索結果表示の改善  
**Problem**: プレーンテキストでの検索結果表示では、各項目の区別が困難で、長時間の検索セッションでは視認性が低下する。また、クエリごとの結果の区切りが分かりにくく、スクロール時の確認が困難。

**Solution**: richライブラリのPanel機能により各検索結果を個別のパネルで表示し、ヘッダー情報（ランク、類似度、ユーザー、日時、URL）を色分けした。検索結果の末尾にRuleによるセパレーターを表示し、クエリごとの区切りを明確化。これにより、大量の検索結果でも効率的な確認が可能になった。

### 終了コマンドの多様化
**Problem**: Ctrl+CやCtrl+Dによる終了は強制的で、一部のユーザーには直感的でない。また、設定メニュー中での誤った終了操作を避けたいニーズがある。

**Solution**: `/exit`、`/quit`、`/q`コマンドによる穏やかな終了オプションを追加。これにより、ユーザーが意図的にプログラムを終了する際の選択肢を増やし、より直感的な操作を可能にした。従来のCtrl+C/Ctrl+D終了も併存させ、様々な操作習慣に対応した。

### リモート検索アーキテクチャへの完全移行
**Problem**: 従来のローカルモード（torch、SentenceTransformer直接利用）では、search.pyの起動時に85秒の重いライブラリ読み込みが発生し、開発時の頻繁な再起動で生産性が大幅に低下していた。また、埋め込みデータの読み込みとベクトル検索処理により、search.pyが重厚になり保守性が低下していた。

**Solution**: ruri_server.pyのWebSocket API を活用したリモート検索アーキテクチャに完全移行。torch、safetensors、SentenceTransformersライブラリをsearch.pyから完全に削除し、軽量なWebSocketクライアントとして再設計した。検索クエリをruri_server.pyに送信し、分割送信される検索結果（post_id、similarity）を受信する方式を採用。これによりsearch.pyの起動時間を数秒に短縮し、ベクトル処理の複雑さをサーバー側に集約した。フィルタリング処理はクライアント側に残し、サーバー側の変更頻度を抑制してデーモンの再起動コストを最小化した。検索アーキテクチャの分離により、フィルタリングやUI機能に集中できる設計を実現した。

### TwilogClientによる通信統一化
**Problem**: search.pyで直接WebSocket通信を実装していたため、通信処理が重複し、保守性が低下していた。また、WebSocketプロトコルの詳細がsearch.pyに混在し、責任の分離ができていなかった。さらに、サーバータイプの確認処理が不十分で、誤ったサーバーに接続する可能性があった。

**Solution**: twilog_client.pyのTwilogClientクラスを活用し、WebSocket通信を統一化。_test_websocket_connection()ではclient.get_status()を使用してサーバータイプが'TwilogServer'であることを確認し、適切なサーバーへの接続を保証。_search_remote()ではclient.vector_search()メソッドを使用し、通信の詳細をクライアントクラスに委譲。これにより、search.pyはフィルタリングとUI処理に集中でき、WebSocket通信の複雑さを分離した。

### 検索エンジンの分離
**Problem**: search.pyにSearchEngineクラスが含まれていたため、メイン処理とベクトル検索処理が混在し、コードの責務が曖昧になっていた。また、検索エンジンの機能を他の場所から再利用することが困難だった。

**Solution**: SearchEngineクラスをsearch_engine.pyに独立したモジュールとして分離し、単一責任原則に従って検索ロジックのみを担当するクラスとして定義。search.pyは対話的UIとコマンド処理に専念し、検索エンジンはインポートして使用する構造に変更。これにより、検索エンジンの再利用性が向上し、コードの保守性が大幅に改善された。
