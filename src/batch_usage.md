# batch_usage.py

## なぜこの実装が存在するか

### バッチ処理結果の構造検証
**Problem**: Gemini APIから取得したバッチ処理結果のJSONLファイルが巨大で、usageMetadataの構造が全行で一貫しているかを手動で確認するのは非現実的だった。

**Solution**: 全行を自動的にチェックして構造の妥当性を検証し、問題のある行を特定できる専用スクリプトを作成した。

### データ品質保証の必要性
**Problem**: 後続の統計処理でusageMetadataの特定フィールドに依存するため、データ構造の不整合があると処理が失敗する可能性があった。

**Solution**: 事前に構造チェックを行い、想定外の構造やフィールド不足を検出して、安全な後続処理を保証する仕組みを導入した。

### 大量データでの効率的な問題発見
**Problem**: 数千〜数万行のJSONLファイルから構造異常を見つけるのは目視では困難で、問題の発生パターンや頻度を把握できなかった。

**Solution**: 行番号付きのエラーレポートと統計情報を提供し、問題の全体像を素早く把握できる分析ツールとして実装した。

### thoughtsTokenCountの発見と対応
**Problem**: 初期のトークン数検証で不整合が検出されたが、原因が不明で後続処理への影響が懸念された。

**Solution**: エラー行の詳細調査により、Gemini APIが内部的に思考プロセスを実行し、その結果をthoughtsTokenCountとして記録していることが判明。このフィールドを計算に含めることで完全な整合性を実現し、思考トークンの使用頻度も追跡できるようにした。

### ブロックされたリクエストの処理
**Problem**: PROHIBITED_CONTENTによりブロックされたリクエストで、candidatesTokenCountフィールドが存在せず構造エラーが発生していた。

**Solution**: promptFeedback.blockReasonの存在を検出し、ブロック時は候補生成が行われないため、candidatesTokenCountを必須フィールドから除外する条件分岐を追加した。ブロックされた行数も統計情報として追跡するようにした。

### 複数ファイル処理と出力最適化
**Problem**: 大量のJSONLファイルを一括処理する際、ファイルごとの詳細出力が冗長で、重要な全体統計が埋もれてしまう問題があった。

**Solution**: 複数ファイル対応とともに、デフォルトでは全体統計のみを表示し、詳細が必要な場合は--verboseオプションで制御できるようにした。シェルのワイルドカード展開を活用して、batch/results/*.jsonlのような一括指定も可能にした。

### keyベースでの正確な対応関係
**Problem**: 行番号ベースでクエリとレスポンスを対応させていたが、バッチ処理結果では行の順序が保持されず、間違った対応が発生していた。

**Solution**: JSONLファイルをkey→dictのマッピングとして読み込み、keyベースで正確にクエリとレスポンスを対応させる仕組みを導入。クエリファイルのキャッシュ機能も追加し、同じファイルの複数エラーに効率的に対応できるようにした。

### UIの簡素化とデフォルト動作の最適化
**Problem**: 複数のオプション（--quiet、--summary-only、--errors-only、--show-content、--verbose）が複雑で、ユーザーが迷いやすく、実際の用途に適していなかった。

**Solution**: 全オプションを削除し、最も実用的な動作をデフォルトとした。ファイルごとの統計を1行で表示し、全体統計、エラー詳細、ブロック詳細を含む包括的な出力を標準とすることで、シンプルで使いやすいツールに仕上げた。

### クエリファイル起点での一元的な処理
**Problem**: レスポンスファイルを直接指定する方式では、対応するクエリファイルの場所を推測する必要があり、バッチ処理のディレクトリ構造に依存した複雑な処理が必要だった。

**Solution**: コマンドライン引数をクエリファイルに変更し、クエリファイルパスから`results/`サブディレクトリ内のレスポンスファイルを自動的に特定する仕組みを導入。処理の起点を明確にし、ファイル管理を単純化した。

### データ完全性の保証
**Problem**: バッチ処理でクエリとレスポンスの対応関係に不整合があっても検出できず、データ品質の問題が見過ごされる可能性があった。

**Solution**: クエリファイルとレスポンスファイルの両方を読み込み、キーの過不足チェックを事前に実行する機能を追加。レスポンスに存在しないキーやクエリに存在しないキーを検出し、データ完全性を保証してから構造チェックを実行する2段階検証システムを構築した。