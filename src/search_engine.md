# 検索エンジン

## なぜこの実装が存在するか

### 検索ロジックの分離と責務統一
**Problem**: search.pyファイルに検索エンジンクラスとメイン処理が混在し、TwilogServerに検索・統計・embeddings管理が混在していた。

**Solution**: SearchEngineクラスを独立したモジュールに分離し、全検索機能を統合。TwilogServerはクエリのベクトル化のみを担当するシンプルなラッパーとして設計。

### 重複除去とフィルタリング統合
**Problem**: 同じユーザーから同じ内容の投稿が複数存在し、ユーザー・日付フィルタリングが検索処理に散在していた。

**Solution**: (user, content)のタプルをキーとした重複チェック機構を常時有効で実装し、より古い投稿を優先。各フィルタリング設定クラスを検索エンジンに統合し、一元的なフィルタリング処理を実現。

### ユーザー・日付フィルタリング機能
**Problem**: 22万件の投稿に対して特定ユーザーや期間に絞った検索を行いたい場合があるが、柔軟な条件指定ができない。

**Solution**: 辞書ベースのフィルタリング設定を実装。
- ユーザー: includes/excludes/threshold_min/threshold_max
- 日付: from/to（YYYYMMDD形式・Y-M-D形式対応）
空の辞書による無効状態の判定により、シンプルで直感的な設計を実現。

### ジェネレーター型検索とメモリ効率化
**Problem**: フィルタリングや重複除去により処理量が予測できず、一括処理では無駄な処理が発生。大量データを一度にメモリに保持すると効率が悪い。

**Solution**: 検索処理をジェネレーター型に設計し、類似度順に投稿を1件ずつ処理。フィルタリング、重複除去、投稿内容取得を順次実行し、必要な件数に達した時点で処理を終了。

### ステートレス設計による並行アクセス対応
**Problem**: SearchEngineがインスタンス変数として設定を保持していたため、複数クライアントからの同時アクセス時に設定が競合していた。

**Solution**: SearchEngineから状態保持を完全に削除し、filter_search()メソッドの引数でSearchSettingsを受け取るステートレス設計に変更。各検索リクエストで独立した設定を使用することで、スレッドセーフな動作を実現。

### ユーザー投稿数データの効率的な活用
**Problem**: UserFilterSettingsがuser_post_countsを内部保持していたため、設定クラスが大量のユーザーデータを抱え込み、設定のシリアライズ時に不要なデータ転送が発生していた。

**Solution**: user_post_countsをUserFilterSettingsから分離し、is_user_allowed()メソッドの引数として渡す設計に変更。SearchEngineが一元管理し、必要時のみデータを参照する効率的なアーキテクチャを実現。

### 遅延初期化アーキテクチャの採用
**Problem**: SearchEngineのコンストラクタでCSV読み込みとembeddings読み込みが即座に実行され、インスタンス生成時に大量のメモリと時間を消費していた。

**Solution**: 遅延初期化パターンを導入し、コンストラクタではパラメータ保存のみを行い、実際の重い処理は明示的な初期化呼び出しまで延期。`initialized`フラグで初期化状態を管理し、インスタンス生成の軽量化と初期化タイミングの制御を両立。

### コンストラクタ引数順序の最適化とディレクトリ管理の柔軟化
**Problem**: SearchEngineがベクトル化機能を持たずTwilogServerに依存していたため単体テストが困難で、固定的なディレクトリ構成のみをサポートしていたため開発環境での運用が制限されていた。

**Solution**: SearchEngineのコンストラクタで`embed_func`を第1引数として配置し、内部で`self._embed_text`として保持することで完全な自己完結を実現。`reasoning_dir`と`summary_dir`をオプション引数として追加し、任意のディレクトリ構成をサポート。メタデータ・CSV設定は内部で管理し、`get_model_name()`メソッドでモデル情報を提供する責務分離を採用。

### VectorStore統合による正確なベクトル管理
**Problem**: 従来の`_load_all_vectors()`実装では、reasoning/summaryベクトルのpost_idsを破棄してcontentのpost_idsを流用していたため、post_idとベクトルの対応関係が破綻し、検索精度が大幅に低下していた。

**Solution**: VectorStoreクラスによる独立したベクトル管理を採用。`content_store`、`reasoning_store`、`summary_store`の3つのVectorStoreインスタンスを使用し、各モードで正確なpost_id→ベクトル対応を保証。`initialize()`メソッド内で指定されたディレクトリパスに基づいて各ストアを初期化し、遅延読み込みによるメモリ効率化も実現。

### 高度なテキスト検索機能の実装
**Problem**: 単純な文字列マッチングでは、複数キーワードの組み合わせや除外条件を含む検索クエリに対応できず、柔軟な検索ができない問題があった。

**Solution**: シェル風パース機能（`text_proc.py`）を導入し、ダブルクォート・エスケープ・除外条件（-記号）をサポート。`search_posts_by_text()`でパースされた条件をAND/NOT論理で処理し、高度なテキスト検索を実現。

### テキストフィルタリング機能の分離
**Problem**: テキスト検索のフィルタリングロジックが`search_posts_by_text()`に埋め込まれており、将来的な複合検索（ベクトル検索結果のテキスト絞り込み）に再利用できない構造だった。

**Solution**: `filter_posts_by_text()`メソッドを分離し、include_terms/exclude_termsを受け取って投稿IDリストを返却する設計に変更。テキストフィルタリングロジックの再利用性を確保し、V→T複合検索の実装基盤を整備。

### V|T複合検索の効率的実装
**Problem**: ベクトル検索とテキスト検索を組み合わせた複合検索で、大量のベクトル検索結果をテキストフィルタリングする際の処理効率が課題だった。

**Solution**: `vector_search`メソッドに`text_filter`引数を追加し、類似度順に1件ずつテキストフィルタリングを実行してtop_kに達したら早期終了する効率的なアルゴリズムを実装。`is_post_text_match`による単一投稿のフィルタリング関数を分離し、V→T処理順序による結果の整合性を保証した。

### 内部API設計によるchunk分割の分離
**Problem**: `vector_search`メソッドでRPC通信用のchunk分割処理（Streaming Extensions対応）を実行していたため、内部APIとして使用する際にも不要な分割処理が実行され、処理が複雑化していた。

**Solution**: SearchEngineの`vector_search`をフラットな`List[Tuple[int, float]]`を返すシンプルな内部APIに変更し、chunk分割処理をRPCレイヤー（twilog_server.py）に移動。内部では単純な配列として処理し、RPC通信時のみStreaming Extensions対応の分割処理を実行する責務分離を実現。これにより、SearchEngineは純粋な検索エンジンとして機能し、通信プロトコルの詳細から分離された。

### 直接ディレクトリ指定による柔軟なベクトル管理
**Problem**: TwilogServerでディレクトリパスを動的に設定する必要があるが、SearchEngineが固定的なディレクトリ構成（batch/reasoning、batch/summary）にハードコードされていたため、柔軟な運用ができなかった。

**Solution**: SearchEngineコンストラクタで`reasoning_dir`と`summary_dir`を直接受け取る設計に変更し、TwilogServerから明示的にディレクトリパスを渡すアーキテクチャを採用。`initialize()`メソッドで指定されたディレクトリが存在する場合のみVectorStoreを初期化し、利用可能なモードを動的に決定。これにより、コマンドライン引数から柔軟なディレクトリ指定が可能になり、開発・テスト環境での運用性が大幅に向上した。


### ジェネレーターによるデータ差異吸収と処理統一化
**Problem**: テキスト検索とベクトル検索で結果形式が異なり、同じフィルタリング処理（ユーザー・日付フィルタ・重複除去）が重複実装されていた。この重複により、保守性が低下し、バグ修正時に複数箇所の変更が必要だった。

**Solution**: `_generate_text_results`と`_generate_vector_results`ジェネレーターを実装し、両方の検索結果を`(post_info, similarity)`形式で統一。`search_similar`内で単一のフィルタリングループを実行し、重複コードを完全排除。ジェネレーターによる遅延評価でメモリ効率も向上し、関数型プログラミングの合成概念をPythonで実現した革新的アーキテクチャを確立。詳細は[ジェネレーター統一化レポート](../docs/20250713-generator-unification.md)参照。

### レーベンシュタイン距離による類似ユーザー検索機能
**Problem**: ユーザー名の入力で タイポや表記ゆれが発生した場合、存在しないユーザーとして処理され、適切な候補が提示されずにユーザー体験が低下していた。特にユーザーフィルタリング設定時に、正確なユーザー名を覚えていない場合の操作性が課題だった。

**Solution**: `suggest_similar_users`メソッドを実装し、Levenshteinライブラリによる高速な文字列類似度計算を採用。入力されたユーザーリストから存在しないユーザーを特定し、全ユーザーとの類似度を計算して上位5人を提案する機能を実現。TwilogDataAccessから提供されるuser_listを活用し、効率的なユーザー名補完支援システムを構築した。

### ハイブリッド検索システムの実装
**Problem**: 単一のベクトル検索では、投稿内容のみの類似度に依存し、タグ付けの理由や要約の情報を活用できない。また、用途に応じた検索モードの選択ができず、一律の検索結果しか得られない。

**Solution**: 3つのベクトル空間（投稿内容、タグ付け理由、要約）を統合したハイブリッド検索システムを実装。詳細な実装内容、API変更、使用例については[ハイブリッド検索システム実装レポート](../docs/20250715-hybrid-search.md)を参照。

**主要な実装内容**:
- 6種類の検索モード（単一ソース検索 + 統合検索）
- 条件付きベクトル読み込みによる段階的機能提供
- ベクトル/テキスト検索の統合インターフェース
- 検索結果のタグ情報自動付加機能

### 共通post_ids管理による効率的なハイブリッド検索
**Problem**: ハイブリッド検索モードで毎回3つのベクトルストアの共通post_idsを計算していたため、検索のたびに集合演算が実行され、処理効率が低下していた。また、統合モードの利用可能性判定も毎回実行する必要があった。

**Solution**: `common_post_ids`をインスタンス変数として初期化時に事前計算し、効率的なハイブリッド検索を実現。`_calculate_common_post_ids()`メソッドで3つのベクトルストア（content、reasoning、summary）が全て存在する場合のみ共通post_idsを計算し、利用可能性を事前判定。これにより、ハイブリッドモードでの検索処理が高速化され、統合検索の実用性が向上した。

### クエリベクトル形状の正規化によるハイブリッドモード互換性
**Problem**: ハイブリッド検索モードで「a Tensor with 768 elements cannot be converted to Scalar」エラーが発生していた。原因は`self._embed_text()`が返すクエリベクトルの形状が`torch.Size([1, 768])`（2次元）だったため、`F.cosine_similarity(...).item()`でスカラー変換に失敗していた。

**Solution**: `vector_search`メソッドでクエリベクトルの形状を自動正規化する処理を追加。`query_vector.squeeze()`により多次元テンソルを1次元に変換し、ハイブリッドモードでのコサイン類似度計算を安定化。これにより、6種類全ての検索モード（content、reasoning、summary、average、product、weighted）が正常動作し、完全なハイブリッド検索システムが実現された。
