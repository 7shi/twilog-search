# 検索エンジン

## なぜこの実装が存在するか

### 検索ロジックの分離
**Problem**: search.pyファイルに検索エンジンクラスとメイン処理が混在し、コードの責務が曖昧になっていた。

**Solution**: SearchEngineクラスを独立したモジュールに分離し、単一責任原則に従って検索ロジックのみを担当するクラスとして定義。

### 重複除去の実装
**Problem**: 同じユーザーから同じ内容の投稿が複数存在する場合、検索結果に重複が発生していた。

**Solution**: (user, content)のタプルをキーとした重複チェック機構を実装し、より古い投稿を優先して表示する方式を採用。

### フィルタリングの統合
**Problem**: ユーザーフィルタリングと日付フィルタリングが検索処理に散在し、フィルタリング条件の管理が複雑化していた。

**Solution**: 各フィルタリング設定クラスを検索エンジンに統合し、一元的なフィルタリング処理を実現。

### ユーザーフィルタリング機能の必要性
**Problem**: 22万件の投稿に対して検索を行う際、特定のユーザーのみ、または特定のユーザーを除外した検索を行いたい場合がある。また、投稿数の多いユーザーや少ないユーザーに絞った検索ニーズもある。

**Solution**: 辞書ベースのフィルタリング設定を実装。
- {}: フィルタリングなし（すべてのユーザー）
- {"includes": [...]}: 指定ユーザーのみを対象
- {"excludes": [...]}: 指定ユーザーを除外
- {"threshold_min": N}: 投稿数N以上のユーザーのみ
- {"threshold_max": N}: 投稿数N以下のユーザーのみ
空の辞書による無効状態の判定により、シンプルで直感的な設計を実現した。

### 日付フィルタリング機能
**Problem**: 時系列での分析や特定期間の投稿に限定した検索のニーズがある。ユーザーフィルタリングだけでは、時間軸での絞り込みができず、検索の精度や有用性が制限される。

**Solution**: 対話的な日付フィルタリング機能を実装。YYYYMMDD形式（例：20230101）とY-M-D形式（例：2023-1-1）の両方をサポートし、柔軟な日付入力を可能にした。
- {}: フィルタリングなし（全期間）
- {"from": timestamp}: 開始日時のみ指定
- {"to": timestamp}: 終了日時のみ指定  
- {"from": timestamp, "to": timestamp}: 期間指定
検索処理では日付チェックをユーザーフィルタリングの後に実行し、効率的な絞り込みを実現。空の辞書による無効状態の判定により、ユーザーフィルタリングと統一された直感的な設計を採用した。

### ジェネレーター型検索アーキテクチャ
**Problem**: フィルタリングや重複除去により、どこまで処理を進める必要があるかが事前に予測できない。一括処理では無駄な処理が発生し、事前最適化も困難になる。また、大量データを一度にメモリに保持すると効率が悪い。

**Solution**: 検索処理をジェネレーター型に設計し、類似度順に投稿を1件ずつ処理する方式を採用。フィルタリング、重複除去、投稿内容取得を順次実行し、利用側で必要な件数に達した時点で処理を終了する。これにより、無駄な処理を削減し、メモリ効率も向上させた。正確性を重視し、パフォーマンス最適化よりも確実な結果取得を優先した設計とした。

### データアクセス層の統合
**Problem**: 検索エンジンが直接データベースアクセスを行うと、データアクセス機能との結合度が高くなり、テストや変更が困難になる。

**Solution**: TwilogDataAccessクラスを依存関係注入パターンで統合し、検索エンジンは抽象化されたインターフェースを通じてデータにアクセスする設計を採用。これにより、データソースの変更（SQLite→CSV等）に対して検索エンジンの修正が不要になり、保守性が向上した。

### ステートレス設計による並行アクセス対応
**Problem**: SearchEngineがインスタンス変数として設定を保持していたため、複数クライアントからの同時アクセス時に設定が競合し、予期しない検索結果が発生する問題があった。

**Solution**: SearchEngineから状態保持を完全に削除し、filter_search()メソッドの引数でSearchSettingsを受け取るステートレス設計に変更。各検索リクエストで独立した設定を使用することで、並行アクセス時の競合を解消し、スレッドセーフな動作を実現した。インスタンス変数はデータアクセス用のpost_user_mapとuser_post_countsのみに限定し、読み取り専用データとして扱う。

### ユーザー投稿数データの効率的な活用
**Problem**: UserFilterSettingsがuser_post_countsを内部保持していたため、設定クラスが大量のユーザーデータを抱え込み、設定のシリアライズ時に不要なデータ転送が発生していた。また、同じユーザーデータが設定クラスとSearchEngineで重複保持される問題があった。

**Solution**: user_post_countsをUserFilterSettingsから分離し、is_user_allowed()メソッドの引数として渡す設計に変更。SearchEngineがself.user_post_countsとして一元管理し、フィルタリング時にis_user_allowed(user, self.user_post_counts)として引数で提供する方式を採用。これにより、ユーザーデータの重複保持を解消し、設定クラスは純粋な設定値のみを管理する軽量な設計を実現した。必要時のみデータを参照する効率的なアーキテクチャとなった。
