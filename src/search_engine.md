# 検索エンジン

## なぜこの実装が存在するか

### 検索ロジックの分離と責務統一
**Problem**: search.pyファイルに検索エンジンクラスとメイン処理が混在し、TwilogServerに検索・統計・embeddings管理が混在していた。

**Solution**: SearchEngineクラスを独立したモジュールに分離し、全検索機能を統合。TwilogServerはクエリのベクトル化のみを担当するシンプルなラッパーとして設計。

### 重複除去とフィルタリング統合
**Problem**: 同じユーザーから同じ内容の投稿が複数存在し、ユーザー・日付フィルタリングが検索処理に散在していた。

**Solution**: (user, content)のタプルをキーとした重複チェック機構を常時有効で実装し、より古い投稿を優先。各フィルタリング設定クラスを検索エンジンに統合し、一元的なフィルタリング処理を実現。

### ユーザー・日付フィルタリング機能
**Problem**: 22万件の投稿に対して特定ユーザーや期間に絞った検索を行いたい場合があるが、柔軟な条件指定ができない。

**Solution**: 辞書ベースのフィルタリング設定を実装。
- ユーザー: includes/excludes/threshold_min/threshold_max
- 日付: from/to（YYYYMMDD形式・Y-M-D形式対応）
空の辞書による無効状態の判定により、シンプルで直感的な設計を実現。

### ジェネレーター型検索とメモリ効率化
**Problem**: フィルタリングや重複除去により処理量が予測できず、一括処理では無駄な処理が発生。大量データを一度にメモリに保持すると効率が悪い。

**Solution**: 検索処理をジェネレーター型に設計し、類似度順に投稿を1件ずつ処理。フィルタリング、重複除去、投稿内容取得を順次実行し、必要な件数に達した時点で処理を終了。

### ステートレス設計による並行アクセス対応
**Problem**: SearchEngineがインスタンス変数として設定を保持していたため、複数クライアントからの同時アクセス時に設定が競合していた。

**Solution**: SearchEngineから状態保持を完全に削除し、filter_search()メソッドの引数でSearchSettingsを受け取るステートレス設計に変更。各検索リクエストで独立した設定を使用することで、スレッドセーフな動作を実現。

### ユーザー投稿数データの効率的な活用
**Problem**: UserFilterSettingsがuser_post_countsを内部保持していたため、設定クラスが大量のユーザーデータを抱え込み、設定のシリアライズ時に不要なデータ転送が発生していた。

**Solution**: user_post_countsをUserFilterSettingsから分離し、is_user_allowed()メソッドの引数として渡す設計に変更。SearchEngineが一元管理し、必要時のみデータを参照する効率的なアーキテクチャを実現。

### 遅延初期化アーキテクチャの採用
**Problem**: SearchEngineのコンストラクタでCSV読み込みとembeddings読み込みが即座に実行され、インスタンス生成時に大量のメモリと時間を消費していた。

**Solution**: 遅延初期化パターンを導入し、コンストラクタではパラメータ保存のみを行い、実際の重い処理は明示的な初期化呼び出しまで延期。`initialized`フラグで初期化状態を管理し、インスタンス生成の軽量化と初期化タイミングの制御を両立。

### コンストラクタ引数順序の最適化とディレクトリ管理の柔軟化
**Problem**: SearchEngineがベクトル化機能を持たずTwilogServerに依存していたため単体テストが困難で、固定的なディレクトリ構成のみをサポートしていたため開発環境での運用が制限されていた。

**Solution**: SearchEngineのコンストラクタで`embed_func`を第1引数として配置し、内部で`self._embed_text`として保持することで完全な自己完結を実現。`reasoning_dir`と`summary_dir`をオプション引数として追加し、任意のディレクトリ構成をサポート。メタデータ・CSV設定は内部で管理し、`get_model_name()`メソッドでモデル情報を提供する責務分離を採用。

### VectorStore統合による正確なベクトル管理
**Problem**: 従来の`_load_all_vectors()`実装では、reasoning/summaryベクトルのpost_idsを破棄してcontentのpost_idsを流用していたため、post_idとベクトルの対応関係が破綻し、検索精度が大幅に低下していた。

**Solution**: VectorStoreクラスによる独立したベクトル管理を採用。`content_store`、`reasoning_store`、`summary_store`の3つのVectorStoreインスタンスを使用し、各モードで正確なpost_id→ベクトル対応を保証。`initialize()`メソッド内で指定されたディレクトリパスに基づいて各ストアを初期化し、遅延読み込みによるメモリ効率化も実現。

### 高度なテキスト検索機能の実装
**Problem**: 単純な文字列マッチングでは、複数キーワードの組み合わせや除外条件を含む検索クエリに対応できず、柔軟な検索ができない問題があった。

**Solution**: シェル風パース機能（`text_proc.py`）を導入し、ダブルクォート・エスケープ・除外条件（-記号）をサポート。`search_posts_by_text()`でパースされた条件をAND/NOT論理で処理し、高度なテキスト検索を実現。

### テキストフィルタリング機能の分離
**Problem**: テキスト検索のフィルタリングロジックが`search_posts_by_text()`に埋め込まれており、将来的な複合検索（ベクトル検索結果のテキスト絞り込み）に再利用できない構造だった。

**Solution**: `filter_posts_by_text()`メソッドを分離し、include_terms/exclude_termsを受け取って投稿IDリストを返却する設計に変更。テキストフィルタリングロジックの再利用性を確保し、V→T複合検索の実装基盤を整備。

### V|T複合検索の効率的実装
**Problem**: ベクトル検索とテキスト検索を組み合わせた複合検索で、大量のベクトル検索結果をテキストフィルタリングする際の処理効率が課題だった。

**Solution**: `vector_search`メソッドに`text_filter`引数を追加し、類似度順に1件ずつテキストフィルタリングを実行してtop_kに達したら早期終了する効率的なアルゴリズムを実装。`is_post_text_match`による単一投稿のフィルタリング関数を分離し、V→T処理順序による結果の整合性を保証した。

### 内部API設計によるchunk分割の分離
**Problem**: `vector_search`メソッドでRPC通信用のchunk分割処理（Streaming Extensions対応）を実行していたため、内部APIとして使用する際にも不要な分割処理が実行され、処理が複雑化していた。

**Solution**: SearchEngineの`vector_search`をフラットな`List[Tuple[int, float]]`を返すシンプルな内部APIに変更し、chunk分割処理をRPCレイヤー（twilog_server.py）に移動。内部では単純な配列として処理し、RPC通信時のみStreaming Extensions対応の分割処理を実行する責務分離を実現。これにより、SearchEngineは純粋な検索エンジンとして機能し、通信プロトコルの詳細から分離された。

### 直接ディレクトリ指定による柔軟なベクトル管理
**Problem**: TwilogServerでディレクトリパスを動的に設定する必要があるが、SearchEngineが固定的なディレクトリ構成（batch/reasoning、batch/summary）にハードコードされていたため、柔軟な運用ができなかった。

**Solution**: SearchEngineコンストラクタで`reasoning_dir`と`summary_dir`を直接受け取る設計に変更し、TwilogServerから明示的にディレクトリパスを渡すアーキテクチャを採用。`initialize()`メソッドで指定されたディレクトリが存在する場合のみVectorStoreを初期化し、利用可能なモードを動的に決定。これにより、コマンドライン引数から柔軟なディレクトリ指定が可能になり、開発・テスト環境での運用性が大幅に向上した。


### ジェネレーターによるデータ差異吸収と処理統一化
**Problem**: テキスト検索とベクトル検索で結果形式が異なり、同じフィルタリング処理（ユーザー・日付フィルタ・重複除去）が重複実装されていた。この重複により、保守性が低下し、バグ修正時に複数箇所の変更が必要だった。

**Solution**: `_generate_text_results`と`_generate_vector_results`ジェネレーターを実装し、両方の検索結果を`(post_info, similarity)`形式で統一。`search_similar`内で単一のフィルタリングループを実行し、重複コードを完全排除。ジェネレーターによる遅延評価でメモリ効率も向上し、関数型プログラミングの合成概念をPythonで実現した革新的アーキテクチャを確立。詳細は[ジェネレーター統一化レポート](../docs/20250713-generator-unification.md)参照。

### レーベンシュタイン距離による類似ユーザー検索機能
**Problem**: ユーザー名の入力で タイポや表記ゆれが発生した場合、存在しないユーザーとして処理され、適切な候補が提示されずにユーザー体験が低下していた。特にユーザーフィルタリング設定時に、正確なユーザー名を覚えていない場合の操作性が課題だった。

**Solution**: `suggest_similar_users`メソッドを実装し、Levenshteinライブラリによる高速な文字列類似度計算を採用。入力されたユーザーリストから存在しないユーザーを特定し、全ユーザーとの類似度を計算して上位5人を提案する機能を実現。TwilogDataAccessから提供されるuser_listを活用し、効率的なユーザー名補完支援システムを構築した。

### ハイブリッド検索システムの実装
**Problem**: 単一のベクトル検索では、投稿内容のみの類似度に依存し、タグ付けの理由や要約の情報を活用できない。また、用途に応じた検索モードの選択ができず、一律の検索結果しか得られない。

**Solution**: 3つのベクトル空間（投稿内容、タグ付け理由、要約）を統合したハイブリッド検索システムを実装。詳細な実装内容、API変更、使用例については[ハイブリッド検索システム実装レポート](../docs/20250715-hybrid-search.md)を参照。

**主要な実装内容**:
- 6種類の検索モード（単一ソース検索 + 統合検索）
- 条件付きベクトル読み込みによる段階的機能提供
- ベクトル/テキスト検索の統合インターフェース
- 検索結果のタグ情報自動付加機能

### 共通post_ids管理による効率的なハイブリッド検索
**Problem**: ハイブリッド検索モードで毎回3つのベクトルストアの共通post_idsを計算していたため、検索のたびに集合演算が実行され、処理効率が低下していた。また、統合モードの利用可能性判定も毎回実行する必要があった。

**Solution**: `common_post_ids`をインスタンス変数として初期化時に事前計算し、効率的なハイブリッド検索を実現。`_calculate_common_post_ids()`メソッドで3つのベクトルストア（content、reasoning、summary）が全て存在する場合のみ共通post_idsを計算し、利用可能性を事前判定。これにより、ハイブリッドモードでの検索処理が高速化され、統合検索の実用性が向上した。

### 統合モードの類似度計算最適化とVectorStoreソート統合
**Problem**: 統合モード（average、maximum、minimum）でコサイン類似度を1つずつpost_idに対してループ内で計算していたため、大量のpost_idを持つデータセットでは処理が遅くなっていた。また、各ベクトルストアでpost_idの順序が異なるため、マスクで取得したベクトルの順序調整が必要だった。

**Solution**: VectorStoreレベルでのpost_idソート機能とSearchEngineでの事前計算ベクトル集合を統合した最適化を実現。VectorStoreの`load_vectors()`でpost_idとベクトルを結合してソートし、post_id順でベクトルを管理。SearchEngineの`_calculate_common_post_ids()`で事前計算されたベクトル集合（common_content_vectors、common_reasoning_vectors、common_summary_vectors）を初期化時に作成し、統合モードではマスクでソート済みベクトルを直接使用。これにより、ループ処理・マスク適用・順序調整を完全に排除し、F.cosine_similarityによる並列計算で最高の処理効率を実現した。

### タグデータ読み込みのエラーハンドリング改善
**Problem**: `_load_tags_data()`メソッドでタグデータの読み込みに失敗した場合、警告メッセージがコンソールに出力され、デバッグ時やテスト時に不要な出力が発生していた。

**Solution**: 例外処理を`pass`文による無言の処理に変更し、タグデータの読み込み失敗を静黙に処理する設計を採用。タグデータは補助的な情報であり、システムの主要機能（検索）に影響を与えないため、失敗時は無言で継続する方針とした。

### クエリベクトル形状の正規化によるハイブリッドモード互換性
**Problem**: ハイブリッド検索モードで「a Tensor with 768 elements cannot be converted to Scalar」エラーが発生していた。原因は`self._embed_text()`が返すクエリベクトルの形状が`torch.Size([1, 768])`（2次元）だったため、`F.cosine_similarity(...).item()`でスカラー変換に失敗していた。

**Solution**: `vector_search`メソッドでクエリベクトルの形状を自動正規化する処理を追加。`query_vector.squeeze()`により多次元テンソルを1次元に変換し、ハイブリッドモードでのコサイン類似度計算を安定化。これにより、6種類全ての検索モード（content、reasoning、summary、average、product、weighted）が正常動作し、完全なハイブリッド検索システムが実現された。

### ハイブリッド検索モードの最適化と統合
**Problem**: productとharmonicモードがaverageモードとほぼ同じランキングを返すため実用的価値が低く、weightedモードが独立存在することでAPI複雑性が増大していた。また、真に差別化された検索結果を提供するモードが不足していた。

**Solution**: 実測テスト結果に基づき、productとharmonicモードを削除し、weightedモードをaverageモードに統合（weights=Noneで均等重み、weights指定で重み付き平均）。新たにmaximum（最高類似度採用）とminimum（最低類似度採用）モードを追加し、明確に差別化された6種類の検索モード（content、reasoning、summary、average、maximum、minimum）による効率的なハイブリッド検索システムを確立。詳細な検証結果と最適化過程については[モード最適化レポート](../docs/20250716-mode-optimization.md)を参照。

### タグデータ管理の一元化とメンテナンス性向上
**Problem**: 補助データ（reasoning、summary、tags）を管理する変数名が`tags_data`となっていたため、reasoningやsummaryデータも含むことが名前から分かりにくく、コードの理解性が低下していた。また、対応するメソッド名も`_load_tags_data`となっており、実際の処理内容との乖離があった。

**Solution**: 変数名を`tags_data`から`summaries_data`に変更し、reasoning、summary、tagsの3種類のデータを含むことを明確化。対応するメソッド名も`_load_summaries_data`に変更し、実際の処理内容を正確に表現。全ての参照箇所を一貫して更新することで、コードの理解性とメンテナンス性を向上させた。タグインデックス構築処理も`summaries_data`からタグ情報を取得する形に統一し、データ管理の一元化を実現。

### suggest_users機能の外部分離とアーキテクチャの簡素化
**Problem**: suggest_users機能がSearchEngine、TwilogServer、TwilogClientに分散実装されており、user_listが取得できれば外部で処理できるにも関わらず、サーバー・クライアント間通信が必要だった。また、レーベンシュタイン距離計算のために検索エンジンに依存する必要があった。

**Solution**: suggest_users機能をSearchEngineから完全に削除し、UserInfoクラスに移動。user_listのみを使用してローカルで類似ユーザーを提案する軽量な実装に変更。サーバー・クライアント側のsuggest_users関連メソッドとコマンドを削除し、通信オーバーヘッドを排除。これにより、SearchEngineの責務を純粋な検索処理に集中させ、ユーザー管理機能を適切に分離したクリーンなアーキテクチャを実現。
