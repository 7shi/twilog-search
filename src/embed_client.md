# embed_client

## なぜこの実装が存在するか

### クラスベースクライアントアーキテクチャの必要性
**Problem**: embed_server.pyがBaseEmbedServerを基底とした継承前提の設計に移行したため、クライアント側も同様の拡張可能なアーキテクチャが必要になった。従来の関数ベースクライアントでは、サーバーの新機能に対応したクライアント拡張が困難だった。

**Solution**: BaseEmbedClientを基底クラスとした継承前提のアーキテクチャを採用。サーバーの追加機能に対応するクライアント拡張を、サブクラスでのメソッドオーバーライドにより実現可能にした。

### 全リクエストタイプのメソッド化による体系化
**Problem**: embed_server.pyがサポートする各リクエストタイプ（status、check_init、stop、embed）を個別に実装する必要があり、統一的なアクセス方法が求められていた。

**Solution**: サーバーの全リクエストタイプに対応するメソッドを実装し、統一的なインターフェースを提供。`get_status()`、`check_init()`、`stop_server()`、`embed_text()`として体系化。

### 共通処理の基底クラス集約による保守性向上
**Problem**: WebSocket通信の接続、送信、受信処理が各リクエストで重複実装されると、エラーハンドリングの統一性や保守性が低下する可能性があった。

**Solution**: `_send_request()`メソッドで共通処理を集約し、各リクエストメソッドは業務ロジックのみに集中。タイムアウト、接続エラー、通信エラーの処理を統一化。

### 継承による機能拡張の標準化
**Problem**: BaseEmbedServerでサブクラスが`handle_additional_request()`で独自機能を追加できる設計のため、クライアント側も対応する拡張機能が必要だった。

**Solution**: `handle_additional_request()`メソッドを基底クラスに実装し、サブクラスでオーバーライドすることで独自リクエストタイプに対応。サーバーとクライアントの拡張パターンを統一。

### レスポンス処理のユーティリティ化
**Problem**: ベクトル化レスポンスの成功判定、データ抽出、Base64デコードなどの処理が各所で重複実装されると、処理の一貫性が保てない。

**Solution**: `is_success()`、`extract_vector_data()`、`decode_vector_size()`をユーティリティメソッドとして実装。レスポンス処理の標準化と再利用性を向上。

### WebSocket RPCの二重ラップアーキテクチャ
**Problem**: WebSocketベースのRPCサーバーに対して、プログラムからのAPI呼び出しとコマンドラインからのCLI操作の両方を提供する必要があった。従来の単一インターフェースでは、利用者のニーズに応じた柔軟な操作方法を提供できなかった。

**Solution**: API Layer（BaseEmbedClient/EmbedClient）とCommand Layer（EmbedCommand）の二重ラップアーキテクチャを採用。WebSocket RPCをPythonのasyncメソッドとしてラップし、さらにそれをCLIコマンドとしてラップすることで、同一サーバーに対する複数のアクセス方法を実現。

### 名前ディスパッチアーキテクチャによるコマンド処理の簡潔化
**Problem**: argparseのサブコマンドを処理する際の長いif-elif文は、新しいコマンドの追加時にコードの保守性を低下させ、実装の重複を招く可能性があった。

**Solution**: EmbedCommandクラスで`getattr(self, args.command)`による動的メソッド呼び出しを採用。サブコマンド名と同名のメソッドを自動的に呼び出すことで、新しいコマンドの追加時はparserとメソッドの追加のみで対応可能にした。この名前ディスパッチパターンはサーバー側のJSON-RPCメソッド処理と統一され、クライアント・サーバー間で一貫したアーキテクチャを実現。

### 継承によるコマンド機能の段階的拡張
**Problem**: 基本的な埋め込み機能に加えて、Twilog固有の検索機能など、用途に応じた拡張コマンドを効率的に実装する必要があった。

**Solution**: EmbedCommandを基底クラスとした継承アーキテクチャにより、基本コマンド（status、check_init、embed、stop）を継承し、用途固有のコマンド（query等）を段階的に追加。コードの重複を避けながら機能拡張を実現。

### JSON-RPC 2.0クライアント統一
**Problem**: 独自JSON形式による通信により、標準的なRPCクライアントライブラリとの互換性がなく、エラーハンドリングも一貫性がなかった。

**Solution**: JSON-RPC 2.0標準に完全準拠したクライアント実装。リクエストは`{"jsonrpc": "2.0", "id": 1, "method": "embed_text", "params": {"text": "..."}}`形式、レスポンスは`{"jsonrpc": "2.0", "id": 1, "result": {...}}`形式で統一し、標準エラーコードによる一貫性のあるエラーハンドリングを実現。

### メソッド名の2語化による一貫性向上
**Problem**: サーバー側の`status`、`stop`、`embed`などの単語メソッド名に対応するクライアント側メソッドの命名が不統一で、APIの理解が困難だった。

**Solution**: 全メソッド名を2語形式に統一（`get_status`、`stop_server`、`embed_text`、`check_init`）し、サーバー側のJSON-RPCメソッド名と完全に一致させた。これにより、クライアント・サーバー間でのメソッド対応関係が明確になり、APIの一貫性を向上。

### 旧形式サポートの完全削除
**Problem**: 後方互換性のために旧形式と新形式の両方をサポートすると、コードが複雑化し、保守性が低下する。

**Solution**: 旧形式のサポートを完全に削除し、JSON-RPC 2.0のみに統一。これにより、コードの簡潔性と保守性を向上させ、標準プロトコルへの完全移行を実現。

### リクエストID連番管理による一意性保証
**Problem**: JSON-RPCリクエストで固定ID（1）を使用すると、複数の並行リクエストや長時間のセッションでレスポンスの対応関係が不明確になり、デバッグや問題追跡が困難になる可能性があった。

**Solution**: グローバル変数`_request_id_counter`による連番管理を実装し、`_get_next_request_id()`関数で各リクエストに一意のIDを割り当て。これによりJSON-RPC標準に準拠した適切なリクエスト・レスポンス対応関係を確立し、通信の透明性とデバッグ容易性を向上。

### Streaming Extensions分割送信の透明な自動結合
**Problem**: サーバー側でStreaming Extensions形式（`{"streaming": [...]}`）により分割送信される大容量データを、クライアント側で個別に処理すると、利用者が分割送信の詳細を意識する必要があり、APIの使いやすさが低下していた。また、チャンク受信処理をサブクラスで重複実装すると、保守性が悪化する問題があった。

**Solution**: `_send_request()`メソッドでStreaming Extensions形式の分割送信を自動検出し、`"more": true`フラグが`false`になるまで連続受信を実行する透明な結合処理を実装。全チャンクの`"data"`フィールドを統合して単一の結果配列として返すことで、利用者は分割送信を一切意識せずに大容量データを取得可能。基底クラスで共通処理を実装することで、サブクラス（TwilogClient等）では通常のAPIと同様にメソッドを呼び出すだけで、大容量検索結果やembeddings一覧を透過的に受信できる設計を実現。

### @rpc_methodデコレーターによるクライアント側セキュリティ強化
**Problem**: `getattr()`による動的メソッド呼び出しにより、クライアント側でも意図しない内部メソッドやプライベートメソッドがコマンドライン経由で呼び出し可能になるセキュリティリスクが存在していた。また、サーバー側の`@rpc_method`デコレーターとクライアント側の実装に対応関係が不明確だった。

**Solution**: クライアント側でも`@rpc_method`デコレーターを導入し、明示的にマークされたメソッドのみをRPC経由で呼び出し可能にする設計を採用。`EmbedCommand.execute()`で`getattr(method, '_is_rpc_method', False)`をチェックし、デコレーターが付与されていないメソッドへのアクセスを遮断。サーバー・クライアント両側で統一されたセキュリティモデルにより、APIの安全性と対応関係の明確性を確保。

### 例外ベースエラーハンドリングによる透明性向上
**Problem**: `_send_request`メソッドでエラーを`{"error": "..."}`辞書形式で返していたため、クライアントコードでエラーハンドリング時に`is_success`チェックと辞書アクセスが必要で、APIが複雑になっていた。また、エラーレスポンスが正常データと混在して返されるため、型安全性が損なわれていた。

**Solution**: エラーを`RuntimeError`例外として発生させる設計に変更し、成功時は常に正常データのみが返される単純なAPIを実現。JSON-RPCエラーは`[エラーコード] エラーメッセージ`形式で詳細情報を保持し、通信エラーや接続エラーも統一的に例外処理。`is_success`メソッドを削除し、例外ベースの一貫したエラーハンドリングによりコードの簡潔性と保守性を向上。

### Base64デコード処理の直接化による簡素化
**Problem**: `_extract_vector_data`と`_decode_vector_size`のヘルパーメソッドにより抽象化層が過剰となり、単純なBase64デコード処理に対してコードが複雑化していた。また、例外ベースエラーハンドリング導入により、これらのユーティリティメソッドの必要性が低下した。

**Solution**: `embed_text_with_details`メソッドで`result.get("vector")`による直接アクセスと`base64.b64decode`による直接デコードを採用。処理の流れが明確になり、不要な抽象化を排除してコードの理解しやすさと保守性を向上。エラー時は自然な例外が発生し、統一されたエラーハンドリングで処理される設計を実現。
