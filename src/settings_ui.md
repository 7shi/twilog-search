# settings_ui

## なぜこの実装が存在するか

### UI機能の純粋関数化
**Problem**: ui_settings.pyでは設定クラスがUIメソッドを持っており、オブジェクト指向の複雑さとUI依存が混在していた。また、設定オブジェクトがUI状態を管理することで、責務が不明確だった。

**Solution**: UI機能を純粋関数として実装し、設定オブジェクトを引数として受け取る設計に変更。関数は設定オブジェクトのメソッドを呼び出して状態を更新するが、自身は状態を持たない。これにより、UI機能の再利用性とテスタビリティが向上した。

### 設定とUIの依存関係の最適化
**Problem**: 設定クラスがUI操作を内包していたため、設定データの利用時にUI関連ライブラリも読み込まれ、無駄なメモリ使用とライブラリ依存が発生していた。

**Solution**: 設定データクラス（settings.py）からUI依存を完全に排除し、UI機能（settings_ui.py）は必要時のみ読み込まれる設計とした。設定データの利用時はUI関連ライブラリが不要となり、軽量な動作を実現。

### UI処理の責務明確化
**Problem**: 設定の変更処理とUI表示処理が密結合しており、設定ロジックの変更がUI表示に影響を与えたり、UI変更が設定ロジックに影響する問題があった。

**Solution**: UI関数は設定オブジェクトのパブリックメソッドのみを呼び出し、設定の内部状態に直接アクセスしない設計とした。設定クラスが提供するAPIを通じて操作することで、設定とUIの責務を明確に分離し、相互依存を最小化した。

### 設定値のデフォルト表示機能
**Problem**: フィルタリング設定の変更時に、現在の設定値が分からないため、意図しない変更や設定の重複入力が発生する。特にthresholdや日付設定では、既存値からの微調整が困難。

**Solution**: 既存設定がある場合のみデフォルト値として表示する方式を実装。未設定時はデフォルト値なしでEnterキーによるキャンセルを可能にした。これにより、既存設定の確認と効率的な編集を両立し、誤操作を防止した。

### 入力値の整合性検証機能
**Problem**: threshold設定で下限>上限、日付設定でfrom>toの矛盾した入力が可能で、検索結果が空になる原因となる。また、無効な日付形式の入力によるエラーが発生する。

**Solution**: 入力時の整合性チェック機能を実装。threshold設定では下限<上限、日付設定ではfrom<toの制約を設け、違反時は赤色のエラーメッセージとともに再入力を求める。日付形式の検証も追加し、無効な入力を事前に排除。これにより、論理的に一貫した設定のみが受け入れられ、予期しない空結果を防止した。

### 設定メニューの操作一貫性設計
**Problem**: 設定メニューでの操作が統一されておらず、ユーザーが操作方法を覚えにくい。また、キャンセルと戻るの概念が混在し、意図しない動作を招く可能性があった。

**Solution**: 全設定メニューで統一された操作体系を採用：
- **Ctrl+D/Ctrl+C**: 何も変更せずメニューに戻る
- **無入力+無設定**: 何も聞かずメニューに戻る  
- **無入力+設定あり**: 消去確認後メニューに戻る
- **Escキー**: 「戻る」表記で穏やかにメニュー終了
設定の種類に応じて適切な終了動作を採用：排他的設定（includes/excludes）は設定後即座に終了、両立可能設定（from/to、min/max）は設定後メニューに戻る。これにより、連続設定が可能で直感的な操作を実現した。

### yes/no選択の標準化
**Problem**: 設定削除確認など、二択の選択場面で統一されたインターフェースがなく、実装の一貫性が保てない問題があった。

**Solution**: `yes_no_menu()`関数を実装し、simple-term-menuを使用した統一された「はい」「いいえ」選択機能を提供。デフォルト選択の指定、キャンセル対応、戻り値の標準化（True/False/None）により、全ての確認場面で一貫した操作性を実現した。これにより、コードの保守性向上と操作の統一感を両立した。

### ユーザー候補選択機能の統合
**Problem**: includes/excludesでユーザー名入力時、存在しないユーザーがそのまま受け入れられ、検索結果が空になる問題があった。また、類似ユーザー名が存在してもユーザーがそれに気づけず、修正機会を失っていた。さらに、includes/excludesで類似した入力処理が重複実装されており、保守性が低下していた。

**Solution**: `suggest_users`機能を統合し、存在しないユーザー名に対する候補選択UIを実装。共通のユーザー入力処理関数`_handle_user_input_with_suggestions`を作成し、includes/excludesで統一的に使用。候補選択メニュー`_show_user_suggestions_menu`では、類似ユーザー選択・直接入力・削除の選択肢を提供し、ループ形式で対象ユーザーを更新する設計とした。直接入力での空欄入力時は候補メニューに戻り、エラー時は候補なしで直接入力・削除のみを提示することで、存在しないユーザーを不適切に通すことを防止。これにより、タイプミスによる設定ミスを大幅に削減し、ユーザビリティを向上させた。

### 検索モード選択メニューの統合
**Problem**: ハイブリッド検索モードの組み込みに伴い、検索モード選択のためのメニューUIが必要となった。既存のユーザーフィルタリング・日付フィルタリング・表示件数設定と統一されたインターフェースを提供しつつ、効率的な操作性を実現する必要があった。

**Solution**: 数字キーショートカットと選択即完了の操作フローを採用した統一メニューシステムを実装。項目の先頭に `[1]`, `[2]`, `[3]`... の番号を配置し、数字キーによる直接選択を可能にし、戻るオプションを常に `[0]` に統一した。選択中項目に `●` マークを付加することで現在の設定を視覚的に明示し、項目選択と同時にメニューから抜けて検索画面に即座復帰する「選択即完了」フローを実現した。averageモードの重み設定ではサブメニューを提供し、ESC/戻るの場合のみ親メニューに復帰する一貫した動作を確立した。詳細な設計方針は [メニューUIの設計方針と実装レポート](../docs/20250716-menu.md) を参照。

### ユーザー名Tab補完機能の統合
**Problem**: ユーザー名入力時に正確な名前を覚えていない場合や、タイポが発生しやすい場合に、入力効率が低下している。既存の類似ユーザー提案機能はあるが、入力中のリアルタイム支援がなく、ユーザビリティが限定的だった。

**Solution**: `safe_text_input_with_user_completion`関数をインポートし、ユーザー名補完機能を統合。`show_user_filter_menu`、`_handle_includes`、`_handle_excludes`関数にuser_listパラメータを追加し、`_handle_user_input_with_suggestions`関数でユーザー一覧が提供された場合（`if user_list:`）に補完付き入力を使用する条件分岐を実装。候補選択時の直接入力では補完機能を使用しない設計とし、適切な場面でのみ補完機能を提供。これにより、入力中のTab補完と入力後の類似ユーザー提案の二段階ユーザー支援システムを実現した。