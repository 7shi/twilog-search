# embed_server

## なぜこの実装が存在するか

### 基底クラス設計による拡張性確保
**Problem**: test_server.pyとruri_server.pyがRuri v3モデルを決め打ちで実装されており、異なるモデルを使用する場合に重複コードが発生し、保守性が低下していた。

**Solution**: 抽象基底クラス`BaseEmbedServer`を導入し、共通機能を基底クラスに集約。モデル初期化処理を抽象メソッド`init_model()`として分離し、継承による拡張を可能にした。

### 動的モデル指定による柔軟性向上
**Problem**: 従来の実装では、モデル名がコード内にハードコーディングされており、異なるモデルを使用する場合にコードの修正が必要だった。

**Solution**: 起動時パラメータ`-m/--model`を必須オプションとして導入し、任意のSentenceTransformerモデルを明示的に指定することを強制。デフォルト値を設けずに、使用するモデルを明確化することで、意図しないモデルの使用を防止。

### 進捗表示におけるモデル名の動的表示
**Problem**: 固定的な「Ruri v3モデル初期化開始...」の表示では、実際に使用されるモデルとの整合性が取れず、ユーザーに混乱を与える可能性があった。

**Solution**: `self.model_name`を使用した動的な進捗表示に変更し、実際に初期化されるモデル名を正確に表示。これにより、複数のモデルを使い分ける際の可視性を向上。

### 抽象化による責務分離
**Problem**: モデル初期化処理と共通のサーバー機能が密結合しており、新しいモデルや特殊な初期化処理を追加する際の影響範囲が大きかった。

**Solution**: `abc.ABC`と`@abstractmethod`を使用して、モデル初期化処理を明確に分離。基底クラスは共通のサーバー機能に集中し、具体的なモデル処理は継承先で実装する設計により、単一責務の原則を徹底。

### 従来アーキテクチャの継承
**Problem**: 新しい設計によって、report-daemon.mdで詳細に記載された実績あるアーキテクチャが失われると、安定性に影響を与える可能性があった。

**Solution**: フロント側一時サーバーによるタイムアウト回避、ポートエラー活用による存在検出、標準入出力切り離しによる完全分離など、test_server.pyの核心技術をそのまま継承。新しい設計は機能拡張のみに留め、安定性を保持。

### 拡張可能なリクエスト処理システム
**Problem**: 基底クラスで固定的にリクエストタイプを処理すると、サブクラスで新しいリクエストタイプを追加する際に基底クラスの修正が必要となり、開放閉鎖原則に反していた。

**Solution**: `handle_additional_request`メソッドによる拡張ポイントを導入。サブクラスで追加のリクエストタイプを処理し、処理できなかった場合は基底クラスに委譲する設計により、既存コードを変更せずに新機能を追加可能にした。

### デーモン起動シーケンスの統一化
**Problem**: サブクラスごとに異なる起動パラメータが必要な場合、従来は複雑なget_daemon_args関数による実装が必要で、引数の受け渡しが煩雑になっていた。

**Solution**: start_daemon関数にdaemon_argsリストを直接受け取る設計に変更し、複雑なデーモン管理ロジック（ポートチェック、進捗待機、プロセス管理、エラーハンドリング）を基底クラスで完全に共通化。サブクラスは単純にdeamon_argsを組み立てるだけで、独自の起動シーケンスを実現。

### サーバー種別の動的識別機能
**Problem**: 同一の基底クラスから継承した複数のサーバー実装が存在する場合、実際に動作しているサーバーの種類を識別する手段がなく、デバッグや運用時の問題特定が困難だった。

**Solution**: `get_status_response`メソッドで`self.__class__.__name__`を使用してクラス名を動的に取得し、サーバー種別情報をstatusレスポンスに含める設計を採用。進捗報告でもサーバー種類を表示することで、起動時からサーバーの正確な識別が可能になり、運用の透明性を大幅に向上。

### 初期化エラーハンドリングシステム
**Problem**: デーモン側で初期化エラーが発生した場合、フロント側は永続的に待機状態となり、エラーの原因が不明で問題の特定が困難だった。

**Solution**: `notify_frontend_error`による明確なエラー通知機能を実装。初期化例外をキャッチしてエラーメッセージをフロント側に送信し、フロント側では`asyncio.wait`でエラーと完了の両方を監視。エラー受信時は適切にリソースを解放して処理を終了し、明確なエラーメッセージを表示する設計を採用。

### パフォーマンス実測値
**実測結果**: Ruri v3モデル（cl-nagoya/ruri-v3-310m）での初期化時間測定

| ライブラリ | 読み込み時間 |
|-----------|-------------|
| torch | 11.28秒 |
| transformers | 12.36秒 |
| sentence_transformers | 37.08秒 |
| モデル初期化 | 23.73秒 |
| **合計** | **84.56秒** |

デーモン分離により、この重い処理をバックグラウンド化し、フロント側の即座起動を実現。

### JSON-RPC 2.0プロトコルの完全準拠
**Problem**: 独自JSON形式による通信により、標準的なRPCクライアントとの互換性がなく、他システムとの連携が困難だった。

**Solution**: JSON-RPC 2.0標準に完全準拠し、リクエストは`{"jsonrpc": "2.0", "id": 1, "method": "embed_text", "params": {"text": "..."}}`、レスポンスは`{"jsonrpc": "2.0", "id": 1, "result": {"vector": "..."}}`形式に統一。標準エラーコード（-32600, -32601, -32602, -32603）による一貫性のあるエラーハンドリングを実現。

### MCP（Model Context Protocol）拡張準備
**Problem**: JSON-RPC 2.0だけでは、将来的にテキスト以外のコンテンツタイプ（画像、音声、リソースなど）を扱う場合の標準的な形式が不足していた。

**Solution**: MCPプロトコル仕様に準拠した拡張準備を実装。現在はJSON-RPC 2.0として動作しているが、将来的にMCPの`content`配列と`type`フィールドによるマルチメディア対応が可能な設計を採用。2層構造（JSON-RPC 2.0層 + MCP層）により、テキスト以外のコンテンツタイプへの拡張性を確保。

### メソッド名の2語化による一貫性向上
**Problem**: `status`、`stop`、`embed`などの単語メソッド名は、機能が複雑化するにつれて曖昧性が生じ、APIの理解しやすさが低下していた。

**Solution**: 全メソッド名を2語形式に統一（`get_status`、`stop_server`、`embed_text`、`check_init`）し、機能を明確に表現。クライアント・サーバー間でメソッド名を完全に一致させ、APIの一貫性と可読性を向上。

### 旧形式サポートの完全削除
**Problem**: 後方互換性のために旧形式と新形式の両方をサポートすると、コードが複雑化し、保守性が低下する。

**Solution**: 旧形式のサポートを完全に削除し、JSON-RPC 2.0のみに統一。これにより、コードの簡潔性と保守性を向上させ、標準プロトコルへの完全移行を実現。

### 名前ディスパッチアーキテクチャによる拡張性向上
**Problem**: handle_clientメソッドでJSON-RPCメソッドを個別にif-elif文で処理すると、新しいメソッドの追加時にコードの保守性が低下し、条件分岐が複雑化していた。

**Solution**: `getattr(self, method)`による動的メソッド呼び出しを採用し、JSON-RPCメソッド名と同名のasyncメソッドを自動的に呼び出す設計に変更。新しいメソッドの追加時は対応するasyncメソッドを実装するだけで済み、handle_clientの修正が不要になった。各メソッドは独立したasyncメソッド（`get_status`、`check_init`、`stop_server`、`embed_text`）として実装され、責務分離と可読性が向上。

### Streaming Extensions対応による大容量データ送信
**Problem**: 検索結果など大容量のデータを一度に送信すると、メモリ使用量が増大し、ネットワーク負荷やレスポンス遅延が問題となる。また、JSON-RPC標準では1リクエスト=1レスポンスが原則のため、大容量データの分割送信に適した仕組みが必要だった。さらに、すべてのリスト返却値を無条件でStreaming Extensions処理すると、通常の構造化データまで平坦化されてしまう問題があった。

**Solution**: Streaming Extensionsパターンを採用し、メソッドが`{"streaming": [...]}`形式の辞書を返した場合のみhandle_clientで自動的に分割送信を実行する選択的処理を実装。判定条件は`isinstance(result, dict) and len(result) == 1 and "streaming" in result`とし、streamingフィールドのみを含む辞書の場合のみStreaming Extensions処理を行う。各チャンクは`{"data": [...], "chunk": 1, "total_chunks": 3, "more": true}`形式でJSON-RPCレスポンスとしてラッピングされ、最終チャンクで`"more": false`となる。メソッド側はチャンク分割ロジックを実装し、handle_client側は単純にJSONRPCでラッピングするだけの責務分離を実現。

### serve_forever()による効率的なサーバー運用
**Problem**: 従来の1秒ごとのポーリングによるサーバー運用（`while self.running: await asyncio.sleep(1)`）は、不要なCPU使用量と非効率的な停止処理を引き起こしていた。

**Solution**: WebSocketサーバーの`serve_forever()`メソッドを採用し、イベント駆動型の効率的なサーバー運用に変更。停止処理は`stop_server`メソッドで`server.close()`と`await server.wait_closed()`を呼び出すことで適切にリソースを解放。BaseEmbedServerクラスに`_start_server()`と`_stop_server()`メソッドを導入し、サーバーライフサイクル管理を統一化。

### モデル指定の必須化によるエラー予防
**Problem**: モデル名が空文字列で初期化された場合、後続のモデル初期化処理で分かりにくいエラーが発生し、問題の特定が困難だった。

**Solution**: `init_model`メソッドの開始時に`self.model_name`の妥当性をチェックし、空文字列や未設定の場合は明確なエラーメッセージ「モデルが指定されていません」を表示する早期エラーハンドリングを実装。これにより、設定ミスやメタデータ不備による問題を初期化段階で迅速に特定可能。

### RPC引数形式の自然な統一化
**Problem**: `params: dict = None`による辞書形式の引数受け渡しにより、メソッドシグネチャが不明確で、IDEの補完機能や型検査が効果的に機能せず、開発効率が低下していた。また、パラメータ抽出のためのboilerplateコードが各メソッドで重複していた。

**Solution**: 各RPCメソッドを自然な引数形式（`text: str`、`limit: int = 50`等）に変更し、`handle_client`で`**params`による展開を行う設計に変更。メソッドシグネチャが明確になり、IDEでの型推論と補完機能が正常に動作。各メソッドからパラメータ抽出処理を削除し、コードの簡潔性と保守性を向上。

### @rpc_methodデコレーターによるセキュリティ強化
**Problem**: `getattr()`による動的メソッド呼び出しにより、意図しないプライベートメソッドや内部メソッドがRPC経由で呼び出し可能になるセキュリティリスクが存在していた。

**Solution**: `@rpc_method`デコレーターを導入し、明示的にマークされたメソッドのみをRPC経由で呼び出し可能にする設計を採用。`handle_client`で`getattr(method_handler, '_is_rpc_method', False)`をチェックし、デコレーターが付与されていないメソッドへのアクセスを遮断。外部からの不正なメソッド呼び出しを防止し、APIの安全性を確保。
